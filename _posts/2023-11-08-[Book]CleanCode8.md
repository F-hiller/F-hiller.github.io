---
title: "[Book] Clean Code - 7주차 (13, 14장)"
date: 2023-11-08 17:22:16 +0900
categories: [Backend, Books, Clean Code]
tags: [clean code, book]
#use_math: true
---

# 동시성

### 🧹동시성이 필요한 이유

coupling(결합)을 없애는 전략이며 what과 when을 분리하는 전략이다.  
동시성을 사용함으로써 구조적 이점, 응답 시간 및 작업 처리량과 관련된 성능 향상을 이룰 수 있다. 이러한 이점으로 정보를 대규모로 분석하는 시스템에서 유용할 것이다.  
<br>

+ 미신과 오해

1. 동시성은 항상 성능을 높여준다.
동시성은 특수한 환경(여러 스레드가 프로세서를 공유하는 환경, 독립적인 계산이 충분히 많은 환경 등)에서 성능 향상을 달성할 수 있다.
2. 동시성을 구현해도 설계는 변하지 않는다.
단지 동시성과 관련한 기능을 추가하는 방식이 아니며 동시성을 고려함에 따라서 시스템 구조가 크게 달라진다.
3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
컨테이너의 작동 방식, 동시 수정과 데드락 문제 해결에 대해서 알고 있어야 한다.  
<br>

+ 올바른 사고

1. 동시성은 부하를 유발한다.
성능 측면에서 부하를 발생시키며 코드를 추가하는 과정이 존재한다.
2. 동시성은 복잡하다.
3. 동시성 버그는 재현하기 어려우며 결함이 아닌 일회성 문제로 무시당하기 쉽다.
4. 동시성을 구현하기 위해서는 설계 전략을 재고해야 한다.  
<br>

### 🧹난관

동시성은 여러 스레드가 동시에 작동하면서 잘못된 결과를 발생시키는 일부 경로(사건)가 생기는 난관이 존재하며 이를 해결할 수 있는 법을 아는 것이 중요하다.  
<br>

### 🧹동시성 방어 원칙

+ 단일 책임 원칙

동시성은 그 자체의 복잡성으로 분리할 이유가 충분하다. 동시성은 다른 코드와는 다른, 독자적인 개발 프로세스와 난관이 존재한다. 잘못 구현한 코드는 에러를 잡기 힘들며 동시성과 관련된 에러만을 해결하는 것도 충분히 어렵다.  
따라서, 동시성 코드를 다른 코드와 분리하는 것을 권장한다.  
<br>

+ 따름 정리 : 자료 범위를 제한하라

여러 스레드가 동시에 접근할 수 있는 영역이 넓어질 수록 문제가 발생할 가능성이 커진다. 보호할 임계영역을 빼먹거나 DRY 위반과 같은 실수들은 버그 탐지를 어렵게 만든다.  
따라서, 자료를 캡슐화하고 공유 자료를 최대한 줄이는 것을 권장한다.  
<br>

+ 따름 정리 : 자료 사본을 사용하라

앞선 이야기가 공유 자료를 최대한 줄이라는 것이었는데 보다 좋은 방법이 바로 처음부터 공유하지 않는 것이다.  
객체를 복사해 읽기 전용으로 사용하는 것으로 해결 가능한데, 객체 복사 비용과 동시성 문제로 인한 lock 부하를 비교해보면 이러한 방식이 도움이 될 수 있다.  
<br>

+ 따름 정리 : 스레드는 가능한 독립적으로 구현하라

스레드는 혼자 존재하도록 구현하는 것이 좋다. 앞서 이야기한 자료 공유 제한부터 시작하여 클라이언트 요청 하나를 담당한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.  
이렇게 작업하면 다른 스레드와 동기화를 할 이유가 없어지며 동기화 문제를 일으킬 가능성을 줄일 수 있다.  
<br>

### 🧹라이브러리를 이해하라

스레드를 사용할 때는 다음을 고려해보는게 좋다.  
1. 스레드 환경에서 안전한 컬렉션을 사용하라
2. 서로 무관한 작업은 executor 프레임워크를 이용하라
3. 가능하다면 스레드의 blocking을 방지하라
4. 일부 클래스 라이브러리는 스레드 환경에서 안전하지 않다  
<br>

+ 스레드 환경에 안전한 컬렉션

java.util.concurrent 패키지에서 제공하는 클래스들은 다중 스레드 환경에서도 안전하며 성능이 좋다.  
ConcurrentHashMap은 대부분의 상황에서 HashMap보다 성능이 좋다고 한다.  
그 외에도 ReentrantLock, Semaphore, CountDownLatch 등의 클래스를 활용하여 스레드 환경을 설계할 수 있다.  
<br>

### 🧹실행모델을 이해하라

동기화 환경, 스레드의 기반이 되는 지식들을 알아보자.  

1. Bound Resource : 다중 스레드 환경에서는 데이터베이스 연결, 읽기/쓰기 버퍼 등의 자원이 제한적이다.
2. Mutual Exclusion : 한 번에 하나의 스레드만 공유 자료와 자원에 접근할 수 있다.
3. Starvation : 특정 스레드가 원하는 자원을 할당받지 못하고 계속 대기하고 있는 상황을 지칭한다.
4. Deadlock : 여러 스레드들이 서로가 가지고 있는 자원을 요청하며 무한정으로 대기하는 상태를 지칭한다.
5. Livelock : 락을 거는 단계에서 스레드끼리 충돌이 발생하여 대기 상황이 이어지는 경우를 지칭한다.  
<br>

+ 생산자와 소비자

생산자, 소비자 스레드는 buffer나 queue를 사용하여 정보를 다룬다. 생산자 스레드는 정보를 채워넣으며 소비자 스레드는 정보를 사용한다.  
생산자 스레드는 빈공간이 있어야 정보를 채워넣을 수 있으며 소비자 스레드는 정보가 담긴 공간이 있어야 정보를 가져와 사용할 수 있다.  
이로인해 두 스레드는 서로의 작업에 대한 신호를 주고 받는데, 스레드 상에서 잘못하면 두 스레드 모두 작동 가능하지만 신호를 대기하고 있는 상황이 발생할 수 있다.  
<br>

+ 읽기와 쓰기

자원을 생산하는 쓰기 스레드는 공유 자원을 생산, 변경하며 읽기 스레드는 자원(정보)를 읽고 사용한다.  
잘못된 경우로 두 스레드 모두 작동 가능한 상황이지만, 서로의 신호를 기다리는 상황도 발생할 수 있다.  
얼마나 빨리 처리하느냐가 중요한 작업이기에 읽기와 쓰기 스레드를 적절히 나눠가면서 사용하는 전략이 필요하다.  
<br>

+ 식사하는 철학자들

동시성에 대해 이야기할 때 자주 등장하는 이야기이다. 유명한 이야기이므로 생략한다.  
[식사하는 철학자들](https://velog.io/@minseojo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C)  
<br>

### 🧹동기화하는 메서드 사이에 존재하는 의존성을 이해하라

당연한 이야기이지만 의존성이 생기면 찾아내기 힘든 버그가 생긴다. 이러한 의존성을 없애고 개별 메서드를 보호하기 위해서 JAVA에서는 synchronized라는 개념을 지원한다.  
하지만 의존성이 있는 메서드가 늘어난다면 구현과 설계를 다시 생각해보는 것이 좋다.  
그럼에도 공유 객체 하나에는 여러 메서드가 필요한 상황이 생기기도 하는데 아래의 3가지 방법을 고려할 수 있다.
1. 클라이언트에서 잠금 : 모든 메서드가 진행되는 동안 클라이언트에서 서버를 잠근 상태로 진행한다.
2. 서버에서 잠금 : 서버 자체에 서버를 잠그고 모든 메서드를 실행한 후 잠금을 푸는 함수를 만든다. 이를 클라이언트가 호출한다.
3. 연결 서버 : 잠금을 진행하는 중간 단계를 생성한다. 서버에서 잠금과 유사하지만 원래 서버는 변경되지 않는다.  
<br>

### 🧹동기화하는 부분을 작게 만들어라

잠금을 실행하는 것은 부하를 가중시키므로 critical section에서만 잠금을 사용하는 것이 좋다.  
즉, 동기화하는 부분을 최대한 작게 만드는 것이 좋다.  
<br>

### 🧹올바른 종료 코드는 구현하기 어렵다

영구적으로 작동하는 시스템과 일시적으로 작동 후 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.  
깔끔하게 종료하는 시스템은 데드락과 같은 현상으로 구현하기 힘들다. 이들을 주의해서 알고리즘을 생각하고 구현하는 것이 중요하다.  
<br>

### 🧹스레드 코드 테스트

스레드 상에서 문제를 노출하는 테스트 케이스를 작성하는 것이 중요하다. 프로그램 설정과 시스템 설정, 부하 등을 바꿔가며 돌리는 것을 권장한다.  
스레드를 이용하는 경우, 여러 번 다시 돌렸더니 에러가 발생하지 않고 통과하는 경우가 발생하기도 하지만 문제가 해결된 것이 아닐 수 있다.  
<br>

+ 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라 : 시스템 실패를 일회성 실패로 간주하면 안된다.

+ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 : 스레드 없이 제대로 작동하는 코드를 우선 작성해야한다.

+ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 : 유연한 코드는 중요하다.

+ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

+ 프로세서 수보다 많은 스레드를 돌려보라 : 문제가 발생하는 지점을 찾기 더 쉬워진다.

+ 다른 플랫폼에서 돌려보라

+ 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라

보조 코드를 작성하는 데에는 2가지 방식이 있다. 최대한 에러가 발생할 것 같은 환경을 만들어서 문제점을 발견하고 해결해야한다.

1. 직접 구현하기

2. 자동화 : AOF, CGLIB, ASM과 같은 도구들이 있다.  
<br>

## 결론

스레드는 항상 중요하다. 동시성 환경에서 에러를 줄이기 위해서는 다음의 지식과 경험이 있어야한다.
1. SRP를 준수한다.
2. 동시성 오류에 대한 원인을 이해한다.
3. 사용하고 있는 라이브러리와 알고리즘을 이해한다.
4. 임계 영역과 Lock에 대해 이해한다.  
<br>

동시성 환경에서는 반드시 문제가 발생하며 테스트를 주의깊게 진행해야한다.  
<br>

# 점진적인 개선 - No Contents.

해당 챕터는 코드를 작성하고 다듬으며 Clean Code를 작성해나가는 과정을 보여주는 챕터이다. 요약을 할 수 없는 챕터이며 기억이 나지 않는다면 다시 한 번 읽어보기를 바란다.