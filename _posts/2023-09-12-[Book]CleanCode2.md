---
title: "[Book] Clean Code - 2주차 (3장)"
date: 2023-09-12 23:20:21 +0900
categories: [Backend, Books, Clean Code]
tags: [clean code, book]
#use_math: true
---
# 함수

### 짧은 함수

함수는 짧을 수록 읽기 좋은 경향을 가진다.

하나의 함수가 10줄이 안되면 좋겠다고 필자는 이야기한다.

그렇게 되면 중첩 구조가 생기는 경우나 들여쓰기가 많아지는 경우도 발생하지 않으며 읽고 이해하기 쉬워진다.  
<br>

### 한 가지 일을 하는 함수

- SOLID 원칙 중 단일 책임 원칙과 유사하다는 생각이 들었다.

함수는 한 가지 일만 하도록 작성해야한다.

한 가지 일이라는 것이 모호해지는 경우가 발생하는데 이는 하나의 일을 해결하는데 여러 단계가 필요할 때다. 더 이상 하나의 이름으로 줄일 수 있는 함수가 존재하지 않는다면 그함수가 하나의 단계가 되는 것이다.  
<br>

### 하나의 함수, 하나의 추상화 수준

```java
void Test () {
	getHtml();
	String pagePathName = PathParser.render(pagePath);
	~.append("\n");
}
```

추상화 수준은 클린 코드에서 제시하는 추상화의 정도를 측정하는 단계이다.

getHtml()과 같이 어떻게 작동하는지 알 수 없으면 추상화 수준이 높다고 이야기하며

.append(”\n”);과 같이 알고 있거나 직관적일수록 추상화 수준이 낮다고 이야기한다. 

String pagePathName = PathParser.render(pagepath); 과 같은 코드는 추상화 수준이 중간이라고 할 수 있겠다.  
<br>

이러한 추상화 수준을 하나의 함수에서 섞어 사용하면 안된다는 것이다.  
<br>

- 내려가기 규칙

선언된 함수의 추상화 수준은 코드가 내려가면서 함께 내려가야한다.

즉, 아래로 갈수록 함수 단위에서 raw code로 작성될 것이다.  
<br>

### Switch 문을 피하는 함수

switch 구문은 작게 만들기 어려우며 한 가지 일을 하게 작성할 수 없다.

해당 구문을 완벽히 배제하는 것은 불가능하므로 여러 방식을 통해서 숨기기도 한다.  
<br>

대표적인 예로, switch 구문을 추상 팩토리 방식에 숨겨 아무에게도 보여주지 않는 방식이 있다. 추상 팩토리 방식이 무엇인지 몰라 잠시 찾아보았다.  

- 추상 팩토리

[💠 추상 팩토리(Abstract Factory) 패턴 - 완벽 마스터하기](https://inpa.tistory.com/entry/GOF-💠-추상-팩토리Abstract-Factory-패턴-제대로-배워보자)

추상 클래스를 바탕으로 만들어진 팩토리 패턴을 추상 팩토리라고 한다.  
<br>

### 서술적인 이름을 사용하는 함수

이름이 조금 길어지더라도 여러 부가적인 설명없이 이해 가능한 함수 이름을 작성하도록 노력하자.

앞선 규칙들을 지키면 이름을 떠올리기가 더 쉬워질 것이다.

일관성 있게 단어를 사용하고 배치하도록 하자.  
<br>

### 인수가 적은 함수

인수가 적을 수록 좋으며 3개 이상은 되도록이면 피하도록 하자.

인수는 함수를 이해하기 어렵게 만들며 테스트하기도 힘들어진다.  
<br>

- 단항 형식

인수로 전달한 대상이 변하는 경우(출력 인수)는 되도록이면 피하는 것이 좋다.

차라리 함수의 반환 값을 통해서 대상의 값을 바꾸는 것이 좋다. 

```java
// 해당 함수가 출력 인수를 사용하지 않으며 입력 인수를 사용하므로 더 권장하는 형태이다.
StringBuffer transform(StringBuffer in){}

// out 인수가 함수를 거치면서 값이 바뀌는 출력 인수로 해당 방식은 권장하지 않는다.
void transform(StringBuffer out){} 
```  
<br>

- 플래그 인수

필자가 “추하고 끔찍하다.”고 표현할 정도로 권장하지 않는다.

부울 형태로 들어오는 플래그 인수의 존재는 해당 함수에서 여러 가지 일을 처리하겠다는 의미라고 해석할 수 있을 것이다. (참과 거짓. 최소 2가지 경우에 따라 다른 일을 진행하므로)  
<br>

- 이항 함수

함수의 인수가 하나 더 생기면 인수 간의 순서가 생기며 해당 순서를 지키지 않아서 발생하는 실수는 매우 자주 일어난다.  
<br>

- 삼항 함수

이항 함수보다 더 이해하기 어려워지며 그에 따라 발생하는 문제도 늘어난다.

```java
double calcuateCircleArea(double x, double y, double radius);

// 아래와 같이 객체로 묶어서 넘기는 것도 하나의 방법이다.
double calcuateCircleArea(Point center, double radius);
```  
<br>

- 인수 목록

String.format()처럼 인수의 수가 가변적인 경우도 있다.

하지만 함수의 선언부를 보면 public String format(String format, Object… args); 와 같이 이항 함수의 형태를 취하고 있다.  
<br>

- 동사나 키워드

의미론적으로 의도와 어울리는 이름이 필요하다.

```java
// 두 예시 모두 아래 함수의 이름이 인수의 의미나 순서를 명확하게 드러내준다.
write(name); 
writeField(name);

assertEquals(expected, actual);
assertExpectedEqualsActual(expected, actual);
```  
<br>

### 부수 효과가 없는 함수

함수의 기능이 이름에 명확히 드러나 있다면 예상치못한 부수 효과를 최대한 방지할 수 있을 것이다.  
<br>

- 출력 인수

일반적으로 함수에게 특정 입력값을 제공하기 위해서 인수를 사용한다.

이를 입력 인수라고 칭하며, 인수가 함수의 결과값이 되는 경우를 출력 인수라고 한다.

이러한 출력 인수는 피하는 것을 권장하며 상태의 변경이 필요한 경우는 함수의 객체 상태를 바꾸는 방식을 선택하기를 바란다.  
<br>

### 명령과 조회가 분리된 함수

함수는 명령과 조회 2개의 역할 중 하나만을 선택해야한다. 

즉, 하나의 함수는 객체 상태를 변경하거나 반환해야한다. 둘을 모두 수행하는 경우는 좋지 않다.  
<br>

명령과 조회를 동시에 하는 경우 다음과 같은 일이 발생한다.

```java
public boolean set(String attribute, String value);
//...
if (set("username", "unclebob")){...}
```

set이라는 함수를 실행한 결과가 왜 if문의 조건문에 있는지 이해하기 힘들다.

조건문을 위한 함수와 set을 위한 함수를 분리해서 작성하도록 하자.  
<br>

### 오류 코드보다 예외가 있는 함수

오류 코드를 사용한다면 위에서 설명한 명령의 기능을 하는 함수가 조건문에 오게되는 경우가 발생한다.

```java
if (deletePage(page) == E_OK){...}
```  
<br>

- try-catch 블록 분리하기

try-catch 블록이 들여쓰기를 비롯하여 구조적 혼란을 가져오며 일반적 논리와 오류 처리를 뒤섞는다고 한다. 따라서, 별도의 함수로 분리할 수 있도록 하자.

```java
public void delete(Page page){
	try{
		deletePageAndAllReferences(page);
	}
	catch (Exception e){
		logError(e);
	}
}
```  
<br>

- 오류 처리도 하나의 작업, 기능이다.

함수는 한 가지 작업만을 해야한다는 원칙으로 보았을 때, 오류를 처리하는 함수는 오직 오류만을 처리해야한다.  
<br>

- 오류 코드의 의존성 자석

오류 코드는 주로 하나의 파일(Error.java)에서 작성하고 관리되며 이는 다른 클래스에서 사용하는 경우 항상 import를 진행해야한다.

오류 코드가 바뀌는 경우, 해당 파일을 import하는 모든 파일에서 재컴파일/재배치가 일어나며 이는 권장하지 않는 방식이다.  
<br>

### 반복하지 않는 함수

같은 알고리즘의 코드를 반복적으로 사용하는 것은 재사용성에서 문제가 생긴다. 해당 알고리즘을 수정해야하는 경우 모든 코드를 직접 수정해야한다.  
<br>

### 참고 : 구조적 프로그래밍

구조적 프로그래밍에서는 return은 하나뿐이며 break, continue 사용을 자제하며 goto의 사용을 절대적으로 금지한다. 

하지만, 필자는 목표와 규율은 이해하나 클린코드에서 이야기하는 작은 함수에서는 큰 의미가 없다고 본다.  
<br>

구조적 프로그래밍이 무엇인지 몰랐었는데 절차적 프로그래밍의 하위 개념이라고도 할 수 있다는 [위키백과](https://ko.wikipedia.org/wiki/%EA%B5%AC%EC%A1%B0%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)의 설명으로 이해할 수 있었다.

### 참고 : 함수 생성하기

함수는 글짓기와 비슷하며 생각을 나열한 후 마음에 들지 않는 것을 계속 고쳐나갈 수 있다.

한번에, 원하는 코드를 작성한 사람은 존재하지 않을 것이다.  
<br>

## 결론 

이번 챕터를 읽으면서 생각한 내용들을 정리하자면 다음과 같다.

1. 추상화 수준이 섞이는 것을 조심하자
2. switch문을 최대한 피하고 숨기자
3. 인수를 적게 사용하자
4. 출력 인수, 플래그 인수는 절대 사용하지 말자
5. 명령과 조회가 분리된 함수를 사용하자
6. try-catch 블록을 분리하자

그 중에서도 가장 인상깊었던 내용은 4번에서 "플래그 인수는 절대 사용하지 말자"이다.

클린코드 저자가 "추하고 끔찍하다"라고 표현한 부분이 있었는데 본인이 플래그 인수를 자주 사용하는 편이어서 조금 마음이 아팠다. 최대한 없앨 수 있도록 노력해봐야겠다.

