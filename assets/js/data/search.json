[ { "title": "[Book] Clean Code - 8주차 (15 ~ 17장)", "url": "/posts/Book-CleanCode9/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-11-14 22:52:55 +0900", "snippet": "JUnit 들여다보기 + SerialDate 리팩터링JUnit 프레임워크는 유명한 자바 프레임워크이다. 그만큼 도움되는 코드와 생각해보고 고칠 수 있는 코드들도 존재한다.또한, SerialDate 클래스는 JCommon 라이브러리에 존재하는 클래스로 날짜를 표현하는 자바 클래스이다.15, 16장은 모두 JUnit과 SerialDate의 코드들을 보면서 클린 코드에 대해 점검하는 시간을 가지고 있다. 하지만, 이들을 글로 옮겨 적기에는 부적절해서 생략하며 직접 읽어보는 편이 더 도움이 되리라 생각한다.냄새와 휴리스틱지금까지 클린 코드란 어떠한 것들이었는지, 휴리스틱과 냄새에 관한 이야기들을 모두 모아서 정리 해보자.Comment (주석) 부적절한 정보 : 다른 시스템을 위한 정보는 주석으로 적절하지 않다. 쓸모 없는 주석 중복된 주석 성의 없는 주석 주석 처리된 코드Environment (환경) 여러 단계로 빌드해야 한다. : 하나의 빌드 과정으로 간단히 빌드할 수 있어야 한다. 여러 단계로 테스트해야 한다. : 하나의 버튼, 하나의 명령으로 테스트가 간단히 진행되어야 한다.Function (함수) 너무 많은 인수 출력 인수 : 인수가 함수의 결과를 나타내서는 안된다. 플래그 인수 : 플래그 인수의 존재는 함수의 기능이 너무 많다는 의미를 가진다. 죽은 함수 : 호출되지 않는 함수는 제거하라.General (일반) 한 소스 파일에 여러 언어 사용 : 자제하는 것이 좋다. 당연한 동작을 구현하지 않는다. : 다른 개발자가 당연하게 여길 만한 동작과 기능을 제공해야 한다. 경계를 올바로 처리하지 않는다. : 시간을 들여 경계 조건을 찾고 테스트하자. 안전 절차 무시 : 컴파일러 경고와 같은 안전 절차를 지켜라. 중복 발생 추상화 수준이 올바르지 못하다. 기초 클래스가 파생 클래스에 의존한다. : 기초 클래스는 파생 클래스를 모르는 상태가 일반적이다. 과도한 정보 : 캡슐화를 비롯하여 외부에 많은 정보가 보이지 않도록 하라. 죽은 코드 : 작동할 수 없는, 작동하지 않는 코드를 제거하라. 수직 분리 : 연관된 내용은 가까운 코드 범위안에 작성하라. 일관성 부족 잡동사니 : 쓸모없는 코드를 제거하라. 인위적 결함 : 관계없는 상수, 변수, 함수, 클래스들은 서로 분리하라. 기능 욕심 : 다른 클래스의 기능을 침범, 의존하지 않도록 작성하라. 선택자 인수 : 인수를 통한 동작 제어(boolean 등)는 자제하라. 모호한 의도 잘못 지운 책임 : 코드는 사용자의 기대에 맞게, 책임(기능)에 맞게 동작해야한다. 부적절한 static 함수 서술적 변수 : 읽기 쉬운 코드를 만들어준다. 이름과 기능이 일치하는 함수 알고리즘을 이해하라. 논리적 의존성은 물리적으로 드러내라. If/Else, Switch/Case보다 다형성을 사용하라. : 다형성을 우선적으로 고려하라. 표준 표기법을 따르라. 매직 숫자는 명명된 상수로 교체하라. : 숫자만으로 의미를 이해할 수 있는 경우를 제외하면 상수로 뜻을 표현하는 것이 좋다. 정확하라. 관례보다 구조를 사용하라. 조건을 캡슐화하라. 부정 조건은 피하라. 함수는 한 가지만 해야한다. 숨겨진 시간적인 결함 일관성을 유지하라. 경계 조건을 캡슐화하라. 함수는 추상화 수준을 한 단계만 내려가야 한다. 설정 정보는 최상위 단계에 둬라. 추이적 탐색을 피하라. : 하나의 모듈은 주변 모듈을 모를수록 좋다.JAVA (자바) 긴 import 목록을 피하고 와일드카드를 사용하라. : 와일드카드를 사용한 import는 사용의 모호함과 충돌 가능성이 존재하지만, 문제가 발생할 확률이 적고 IDE의 기능들을 사용함으로써 와일드카드 사용을 더 추천한다고 한다. 상수는 상속하지 않는다. 상수 대 Enum : public static final int와 같은 옛날 방식 대신 Enum을 사용하자.Naming (이름) 서술적인 이름을 사용하라. 적절한 추상화 수준에서 이름을 선택하라. 가능하다면 표준 명명법을 사용하라. 명확한 이름 긴 범위는 긴 이름을 사용하라. 인코딩을 피하라. : 과거 개발 환경에서 정보를 표현하기 위해 사용했던 접두어들은 이제 필요하지 않다. 이름으로 부수 효과를 설명하라.Test (테스트) 불충분한 테스트 커버리지 도구를 사용하라. 사소한 테스트를 건너뛰지 마라. 무시한 테스트는 모호함을 뜻한다. 경계 조건을 테스트하라. 버그 주변은 철저히 테스트하라. 실패 패턴을 살펴라. 테스트 커버리지 패턴을 살펴라. 테스트는 빨라야 한다.결론많다면 많고, 적다면 적은 목록들이다. 이러한 디테일 하나하나가 모여서 클린 코드가 되며, 일부 규칙만을 따른다고 해서 클린 코드가 될 수 없다.사소한 가치들이 모여서 습관, 전문가 정신, 장인 정신을 만들며 소프트웨어 장인으로 향할 수 있는 길이 될 것이다." }, { "title": "[Book] Clean Code - 7주차 (13, 14장)", "url": "/posts/Book-CleanCode8/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-11-08 17:22:16 +0900", "snippet": "동시성🧹동시성이 필요한 이유coupling(결합)을 없애는 전략이며 what과 when을 분리하는 전략이다.동시성을 사용함으로써 구조적 이점, 응답 시간 및 작업 처리량과 관련된 성능 향상을 이룰 수 있다. 이러한 이점으로 정보를 대규모로 분석하는 시스템에서 유용할 것이다. 미신과 오해 동시성은 항상 성능을 높여준다.동시성은 특수한 환경(여러 스레드가 프로세서를 공유하는 환경, 독립적인 계산이 충분히 많은 환경 등)에서 성능 향상을 달성할 수 있다. 동시성을 구현해도 설계는 변하지 않는다.단지 동시성과 관련한 기능을 추가하는 방식이 아니며 동시성을 고려함에 따라서 시스템 구조가 크게 달라진다. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.컨테이너의 작동 방식, 동시 수정과 데드락 문제 해결에 대해서 알고 있어야 한다. 올바른 사고 동시성은 부하를 유발한다.성능 측면에서 부하를 발생시키며 코드를 추가하는 과정이 존재한다. 동시성은 복잡하다. 동시성 버그는 재현하기 어려우며 결함이 아닌 일회성 문제로 무시당하기 쉽다. 동시성을 구현하기 위해서는 설계 전략을 재고해야 한다.🧹난관동시성은 여러 스레드가 동시에 작동하면서 잘못된 결과를 발생시키는 일부 경로(사건)가 생기는 난관이 존재하며 이를 해결할 수 있는 법을 아는 것이 중요하다.🧹동시성 방어 원칙 단일 책임 원칙동시성은 그 자체의 복잡성으로 분리할 이유가 충분하다. 동시성은 다른 코드와는 다른, 독자적인 개발 프로세스와 난관이 존재한다. 잘못 구현한 코드는 에러를 잡기 힘들며 동시성과 관련된 에러만을 해결하는 것도 충분히 어렵다.따라서, 동시성 코드를 다른 코드와 분리하는 것을 권장한다. 따름 정리 : 자료 범위를 제한하라여러 스레드가 동시에 접근할 수 있는 영역이 넓어질 수록 문제가 발생할 가능성이 커진다. 보호할 임계영역을 빼먹거나 DRY 위반과 같은 실수들은 버그 탐지를 어렵게 만든다.따라서, 자료를 캡슐화하고 공유 자료를 최대한 줄이는 것을 권장한다. 따름 정리 : 자료 사본을 사용하라앞선 이야기가 공유 자료를 최대한 줄이라는 것이었는데 보다 좋은 방법이 바로 처음부터 공유하지 않는 것이다.객체를 복사해 읽기 전용으로 사용하는 것으로 해결 가능한데, 객체 복사 비용과 동시성 문제로 인한 lock 부하를 비교해보면 이러한 방식이 도움이 될 수 있다. 따름 정리 : 스레드는 가능한 독립적으로 구현하라스레드는 혼자 존재하도록 구현하는 것이 좋다. 앞서 이야기한 자료 공유 제한부터 시작하여 클라이언트 요청 하나를 담당한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.이렇게 작업하면 다른 스레드와 동기화를 할 이유가 없어지며 동기화 문제를 일으킬 가능성을 줄일 수 있다.🧹라이브러리를 이해하라스레드를 사용할 때는 다음을 고려해보는게 좋다. 스레드 환경에서 안전한 컬렉션을 사용하라 서로 무관한 작업은 executor 프레임워크를 이용하라 가능하다면 스레드의 blocking을 방지하라 일부 클래스 라이브러리는 스레드 환경에서 안전하지 않다 스레드 환경에 안전한 컬렉션java.util.concurrent 패키지에서 제공하는 클래스들은 다중 스레드 환경에서도 안전하며 성능이 좋다.ConcurrentHashMap은 대부분의 상황에서 HashMap보다 성능이 좋다고 한다.그 외에도 ReentrantLock, Semaphore, CountDownLatch 등의 클래스를 활용하여 스레드 환경을 설계할 수 있다.🧹실행모델을 이해하라동기화 환경, 스레드의 기반이 되는 지식들을 알아보자. Bound Resource : 다중 스레드 환경에서는 데이터베이스 연결, 읽기/쓰기 버퍼 등의 자원이 제한적이다. Mutual Exclusion : 한 번에 하나의 스레드만 공유 자료와 자원에 접근할 수 있다. Starvation : 특정 스레드가 원하는 자원을 할당받지 못하고 계속 대기하고 있는 상황을 지칭한다. Deadlock : 여러 스레드들이 서로가 가지고 있는 자원을 요청하며 무한정으로 대기하는 상태를 지칭한다. Livelock : 락을 거는 단계에서 스레드끼리 충돌이 발생하여 대기 상황이 이어지는 경우를 지칭한다. 생산자와 소비자생산자, 소비자 스레드는 buffer나 queue를 사용하여 정보를 다룬다. 생산자 스레드는 정보를 채워넣으며 소비자 스레드는 정보를 사용한다.생산자 스레드는 빈공간이 있어야 정보를 채워넣을 수 있으며 소비자 스레드는 정보가 담긴 공간이 있어야 정보를 가져와 사용할 수 있다.이로인해 두 스레드는 서로의 작업에 대한 신호를 주고 받는데, 스레드 상에서 잘못하면 두 스레드 모두 작동 가능하지만 신호를 대기하고 있는 상황이 발생할 수 있다. 읽기와 쓰기자원을 생산하는 쓰기 스레드는 공유 자원을 생산, 변경하며 읽기 스레드는 자원(정보)를 읽고 사용한다.잘못된 경우로 두 스레드 모두 작동 가능한 상황이지만, 서로의 신호를 기다리는 상황도 발생할 수 있다.얼마나 빨리 처리하느냐가 중요한 작업이기에 읽기와 쓰기 스레드를 적절히 나눠가면서 사용하는 전략이 필요하다. 식사하는 철학자들동시성에 대해 이야기할 때 자주 등장하는 이야기이다. 유명한 이야기이므로 생략한다.식사하는 철학자들🧹동기화하는 메서드 사이에 존재하는 의존성을 이해하라당연한 이야기이지만 의존성이 생기면 찾아내기 힘든 버그가 생긴다. 이러한 의존성을 없애고 개별 메서드를 보호하기 위해서 JAVA에서는 synchronized라는 개념을 지원한다.하지만 의존성이 있는 메서드가 늘어난다면 구현과 설계를 다시 생각해보는 것이 좋다.그럼에도 공유 객체 하나에는 여러 메서드가 필요한 상황이 생기기도 하는데 아래의 3가지 방법을 고려할 수 있다. 클라이언트에서 잠금 : 모든 메서드가 진행되는 동안 클라이언트에서 서버를 잠근 상태로 진행한다. 서버에서 잠금 : 서버 자체에 서버를 잠그고 모든 메서드를 실행한 후 잠금을 푸는 함수를 만든다. 이를 클라이언트가 호출한다. 연결 서버 : 잠금을 진행하는 중간 단계를 생성한다. 서버에서 잠금과 유사하지만 원래 서버는 변경되지 않는다.🧹동기화하는 부분을 작게 만들어라잠금을 실행하는 것은 부하를 가중시키므로 critical section에서만 잠금을 사용하는 것이 좋다.즉, 동기화하는 부분을 최대한 작게 만드는 것이 좋다.🧹올바른 종료 코드는 구현하기 어렵다영구적으로 작동하는 시스템과 일시적으로 작동 후 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.깔끔하게 종료하는 시스템은 데드락과 같은 현상으로 구현하기 힘들다. 이들을 주의해서 알고리즘을 생각하고 구현하는 것이 중요하다.🧹스레드 코드 테스트스레드 상에서 문제를 노출하는 테스트 케이스를 작성하는 것이 중요하다. 프로그램 설정과 시스템 설정, 부하 등을 바꿔가며 돌리는 것을 권장한다.스레드를 이용하는 경우, 여러 번 다시 돌렸더니 에러가 발생하지 않고 통과하는 경우가 발생하기도 하지만 문제가 해결된 것이 아닐 수 있다. 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라 : 시스템 실패를 일회성 실패로 간주하면 안된다. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 : 스레드 없이 제대로 작동하는 코드를 우선 작성해야한다. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 : 유연한 코드는 중요하다. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라 프로세서 수보다 많은 스레드를 돌려보라 : 문제가 발생하는 지점을 찾기 더 쉬워진다. 다른 플랫폼에서 돌려보라 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 보조 코드를 작성하는 데에는 2가지 방식이 있다. 최대한 에러가 발생할 것 같은 환경을 만들어서 문제점을 발견하고 해결해야한다. 직접 구현하기 자동화 : AOF, CGLIB, ASM과 같은 도구들이 있다. 결론스레드는 항상 중요하다. 동시성 환경에서 에러를 줄이기 위해서는 다음의 지식과 경험이 있어야한다. SRP를 준수한다. 동시성 오류에 대한 원인을 이해한다. 사용하고 있는 라이브러리와 알고리즘을 이해한다. 임계 영역과 Lock에 대해 이해한다.동시성 환경에서는 반드시 문제가 발생하며 테스트를 주의깊게 진행해야한다.점진적인 개선 - No Contents.해당 챕터는 코드를 작성하고 다듬으며 Clean Code를 작성해나가는 과정을 보여주는 챕터이다. 요약을 할 수 없는 챕터이며 기억이 나지 않는다면 다시 한 번 읽어보기를 바란다." }, { "title": "[Book] Clean Code - 6주차 (11, 12장)", "url": "/posts/Book-CleanCode7/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-10-31 23:45:42 +0900", "snippet": "시스템한 사람이 도시 전체를 이해하지 않아도, 여러 사람들이 모여 도시를 운영해나갈 수 있다. 이러한 것이 가능한 이유가 적절한 추상화와 모듈화이다.🧹시스템의 제작과 사용을 분리하라건물을 제작할 때는 기중기와 승강기가 있으며 안전모에 작업복을 입은 사람들이 돌아다닌다. 반면, 건물을 사용할 때에는 기중기와 승강기는 사라지고 건물을 실제로 사용하는 사람들이 돌아다닐 것이다.이러한 내용을 소프트웨어 단계로 옮겨본다면, 시스템은 객체를 제작하고 의존성을 연결하는 준비 과정과 준비 과정 이후 발생하는 런타임 로직을 분리해야한다.🧹Main 분리생성과 관련한 코드는 main과 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정하는 환경이다.이러한 상황은 아주 간단한 로직으로 이루어진다. main 함수가 시스템에 필요한 객체를 생성한 후 애플리케이션에서 객체를 넘겨받아 사용하면 된다. 팩토리객체가 생성되는 시점을 main이 아닌 애플리케이션에서 결정해줘야하는 경우가 존재한다. 이런 경우, Abstract Factory 패턴을 사용할 수 있다.이렇게 되면 LineItem을 생성하는 시점은 애플리케이션이 결정하지만, 생성 과정이나 로직은 알지 못하도록 구성할 수 있다. 의존성 주입또다른 메커니즘으로는 의존성 주입이 존재한다. 의존성 주입을 통해서 수동적인 클래스의 한계를 벗어날 수 있다.🧹확장 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍쳐는 점진적으로 발전할 수 있다. 횡단(cross-cutting) 관심사영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있으며 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야한다.같은 명명 관례, 일관적인 트랜잭션 의미 등을 사용하는 것이 바람직한 방향이다.🧹자바 프록시자바 프록시는 개별 객체나 클래스에서 메서드 호출을 감싸는 경우와 같이 단순한 상황에 적합하다. 하지만 JDK에서 제공하는 동적 프록시는 인터페이스만 지원하고 있으며 클래스 프록시를 사용하기 위해서는 여러 바이트 코드 처리 라이브러리를 사용해야한다.하지만, 자바 프록시를 사용하면서 발생하는 코드 양과 크기가 프록시의 두 가지 단점으로 꼽히기도 한다. 따라서 프록시를 사용하는 것이 깨끗한 코드를 작성하기 어렵다고 볼 수 있다. 또한, 시스템 단위로 실행 지점을 명시할 수 있는 메커니즘을 제공하지 않는다는 점에서 사용할 이유가 적은 방식이다.🧹순수 자바 AOP 프레임워크자바 프록시를 사용하지 않고 이를 대체할 수 있는 방법 중 하나로 프레임워크의 사용이 있다. 프록시 코드는 대부분 서로 유사하여 프레임워크 도구 등으로 자동화할 수 있다. 따라서 스프링 AOP 등을 비롯한 자바 프레임워크 내부에서 사용하는 프록시를 이용할 수 있다. 스프링에서는 Annotation을 이용하여 코드를 더 깨끗하게 만들었으며 테스트와 유지보수를 더욱 쉽게 할 수 있게 되었다.🧹AspectJ 관점관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ언어라고 한다. 자바 언어의 확장으로 스프링 AOP와 같이 순수 자바 방식으로도 다룰 수 없는 복잡한 상황을 해결해줄 수 있다는 장점이 있지만 새로운 도구와 언어 문법을 익혀야한다는 것이 단점으로 꼽힌다.🧹테스트 주도 시스템 아키텍처 구축앞에서 이야기한 내용들을 토대로 애플리케이션 도메인 논리를 POJO로 작성한다면 테스트 주도 아키텍처 구축이 가능해지며 여러 기능, 기술들이 추가되며 복잡한 아키텍쳐로 키워갈 수 있다. 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.🧹의사 결정을 최적화하라 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다.🧹명백한 가치가 있을 때 표준을 현명하게 사용하라 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.🧹시스템은 도메인 특화 언어가 필요하다 도메인 특화 언어 DSL을 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.결론모든 추상화 단계에서 의도는 명확히 표현해야한다. 그러기 위해서는 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야한다.아직은 해당 챕터의 내용을 전부 이해하지는 못했다. POJO, AOP는 아직까지 완벽히 이해하기 어려운 것 같다. 관련 코드를 자주 접하다보면 자연스럽게 이해할 날이 올 것이라고 생각한다.창발성켄트 벡이 이야기하는 단순한 설계 규칙 4가지가 소프트웨어 설게 품질을 크게 높여준다고 한다. 모든 테스트를 실행한다 중복을 없앤다 프로그래머 의도를 표현한다 클래스와 메서드 수를 최소로 줄인다하나씩 알아보도록 하자.🧹모든 테스트를 실행하라설계는 의도한 대로 돌아가는 시스템을 완성해야한다. 이를 인정받기 위해서는 테스트가 중요하다. 철저한 테스트가 가능한 시스템을 만들면 더 좋은 설계가 완성된다.이는 낮은 결합도와 높은 응집력이라는 결과를 가져다 줄 것이다.🧹리팩터링테스트 케이스의 연장선인 리팩터링이 있다. 리팩터링을 할 때에는 코드를 수정하는 결과가 설계 품질을 낮추는지, 기존 기능을 깨뜨리지 않았는지 생각해봐야한다. 하지만, 이러한 내용들도 테스트가 잘 짜여있다면 걱정하지 않아도 된다. 이 단계에서는, 응집도 높이기, 결합도 낮추기, 관심사 분리ㅏ기, 시스템 관심사 모듈로 나누기, 함수와 클래스 크기 줄이기, 더 나은 이름 짓기 등과 같이 다양한 기법들을 동원하여 수정할 수 있다.🧹증복을 없애라중복은 추가 작업, 추가 위험, 불필요한 복잡도를 가지고 있는 커다란 적이다. 비슷한, 중복있는 코드들을 더욱 비슷하거나 아예 합쳐버리는 방향으로 나가면 리팩터링이 더 쉬워질 것이다. TEMPLATE METHOD 패턴은 고차원 중복을 제거하는 목적으로 자주 사용하는 기법이므로 알아두는 것이 좋다.TEMPLATE METHOD PATTERN🧹표현하라스스로 작성하는 코드는 이해하기 쉽다. 하지만 시간이 지나거나, 다른 사람이 작성한 코드를 본다면 바로 이해하기 힘든 경우가 많다. 따라서 코드에는 개발자의 의도를 분명히 담아야한다. 좋은 이름 : 좋은 이름은 그 자체로 좋은 문서가 된다 함수와 클래스 크기 줄이기 : 크기가 작아질수록 구현과 이해가 쉬워진다. 표준 명칭 사용 : 표준 패턴과 관련된 이름들을 클래스 이름에 포함하는 것이 좋다. 단위 테스트 케이스 작성 : 테스트 케이스는 예제로 보여주는 문서가 될 수 있다. 노력 : 코드에 의도를 담는 노력을 하지 않으면 아무 의미가 없다.🧹클래스와 메서드 수를 최소로 줄여라함수와 클래스의 길이를 줄이라고 앞서 수없이 강조했다. 하지만, 이것들도 극단으로 치닫는다면 분명 비효율적인 시점이 올 수 있다. 유지보수와 수정 단계에서 이러한 과정이 극단적이지는 않았는지 클래스와 메서드 수를 줄여보는 시도를 하는 것이 실용적일 수 있다.결론경험을 대신할 단순한 개발 기법은 존재하지 않는다. 하지만 이러한 내용 하나하나가 한번의 경험을 대신해줄 것이라고 생각한다. 그러므로 우수한 기법과 원칙에서 기원한 설계 규칙, 패턴 등에 대해서 조금 더 공부할 필요성을 느끼고 있다." }, { "title": "[Book Clean Code - 5주차 (9, 10장)", "url": "/posts/Book-CleanCode6/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-10-09 00:30:36 +0900", "snippet": "단위 테스트🧹TDD 법칙 3가지 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.🧹깨끗한 테스트 코드 유지하기테스트 코드는 추가되는 경우는 있어도 없어지는 경우는 잘 없다. 그렇기에 유지보수 비용에 포함되며 깨끗하지 않은 테스트 코드는 팀의 부담을 증가시키며 테스트 코드를 폐기하게 만드는 스노우볼이 된다.유연성, 유지보수성, 재사용성이 있는 테스트 코드는 코드의 변경이 쉽게 이루어지도록 도우며 시스템의 안정성을 책임진다.🧹깨끗한 테스트 코드그렇다면 깨끗한 테스트 코드는 무엇일까?저자는 가독성이라고 이야기한다.테스트는 실제 코드보다도 더욱 가독성이 중시되어야한다고 이야기한다. 하지만, 실제 코드만큼 효율적일 필요는 없다.🧹테스트 당 assert 하나JUnit으로 작성한 테스트 코드는 함수마다 assert 문을 하나만 사용하라고 주장하는 사람들도 있다.가혹하다고 여길지 몰라도 장점이 있다고 한다.assert 문이 하나인 함수는 제시하는 결론도 하나이므로 코드를 이해하기 쉽고 빠르다. 이는, 앞서 이야기한 가독성의 측면에서 훌륭하다고 할 수 있다.given-when-then 관례를 지키는 것도 이러한 측면이라고 볼 수 있다.assert 문을 하나만 쓰는 것은 분명 훌륭하다. 때에 따라서 1개만 사용하는 것이 힘들기도 하지만 assert 문의 개수는 최대한 줄이는 것이 좋은 방향이라고 한다.🧹테스트 당 개념 하나이것 저것 연속적으로 테스트하는 긴 함수는 작성하지 말라는 의미이다.직관적으로 확인할 수 있는 규칙에 따라 함수들을 나누어서 작성하다보면 미쳐 발견하지 못한 테스트들을 추가할 수 있을 것이다.🧹FIRST 규칙깨끗한 테스트를 만족하는 5가지 조건이다.Fast : 테스트는 빨라야한다. 테스트는 여러번 돌리기 마련이다. 느리면 테스트를 진행하기 힘들어진다.Independent : 각 테스트는 의존성이 없어야한다. 한 테스트가 다음 테스트를 위한 발판이 되어서는 안된다.Repeatable : 테스트는 어떤 상황에서도 반복 가능해야한다.Self-Validating : 테스트는 boolean 값으로 결론나야한다. 성공 혹은 실패의 결과만이 존재해야한다. 테스트 로그나 파일들을 개발자가 직접 확인해야하는 일은 없어야 할 것이다.Timely : 테스트는 적절한 시기에 작성되어야한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.결론테스트는 시스템을 유지해주는 중요한 수단이며, 소홀히 관리해서는 안된다. 또한 단일 assert, FIRST 규칙과 같은 내용들을 준수하면서 테스트 코드를 작성할 수 있도록 노력해보자.클래스지금까지의 챕터는 대부분 함수 단계에서의 깨끗함에 대해 이야기해왔다. 하지만 코드란 것은 함수만으로 이루어진 것이 아니며 더 높은 차원, 클래스의 깨끗함에도 신경을 써야한다. 이번에는 클래스에 대해서 이야기해보도록 하자.🧹클래스 체계클래스를 정의하는 표준 자바 관례에 따르면 처음에는 변수 목록이 나온다. static public 상수가 가장 먼저, 그 뒤를 이어서 static private 변수, private 인스턴스 변수가 나온다. 클래스 상에서 public 변수를 사용하는 경우는 거의 없다고 볼 수 있다. 그 이후에는 public 함수가 나온다. private 함수는 자신을 호출하는 public 함수 직후에 나온다. 이렇듯, 추상화 단계가 순차적으로 내려가는 방식으로 클래스를 전개한다고 볼 수 있다. 캡슐화변수와 유틸리티 함수는 공개하지 않는 편이 좋지만 테스트 환경에서의 사용과 같이 필요한 경우에는 protected로 선언에 접근을 허용하기도 한다.그렇지만 되도록이면 캡슐화를 벗어나지 않도록 시도해보자. 캡슐화 해제는 최후의 수단이다.🧹클래스는 작아야 한다함수 단계에서 이야기한 맥락과 유사하면서도 차이점이 존재한다. 클래스의 설계 방향이 작아야 한다는 점이 유사하다. 하지만 함수의 경우 물리적인 행의 길이가 작아야한다는 방향성을 지니고 있었지만 클래스의 경우에는 해당 클래스가 가지고 있는 책임이 작아야한다는 것이다. 클래스의 이름은 클래스의 책임을 기술하고 있으며 작명을 잘하는 것이 클래스의 책임을 명확히하는 길이다. 이름에 Processor, Manager, Super와 같이 모호하거나 범위가 방대한 내용이 포함되었다면 클래스가 여러 책임을 가지고 있지는 않은가 생각해보자.또한 클래스의 설명이 만약(if), 그리고(and), ~하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야한다고 한다. 너무 구체적인 지시이긴 하지만, 결국 말이 길어질 정도로 책임과 조건이 많아서는 안된다는 의미일 것이다. 다음의 코드를 예시로 들 수 있다.public class SuperDashBoard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent(); public void setLastFocused(Component lastFocused); public int getMajorVersionNumber(); public int getMinorversionNumber(); public int getBuildNumber(); }위 클래스를 설명하려면 어떻게 해야할까? “SuperDashBoard 클래스는 마지막으로 포커스를 얻었던 컴포넌트에 접근하는 방법을 제공하며, 버전과 빌드 번호를 추적하는 메커니즘을 제공한다.”와 같이 설명할 수 있다고 한다. “~하며”가 사용되었으므로 책임이 많은 클래스라고 볼 수 있다. 단일 책임 원칙SOLID 원칙의 1번째 원칙인 Single Responsibility Principle은 클래스나 모듈을 변경할 이유가 단 하나여야한다는 원칙이다. 이는 클래스가 하나의 책임을 가져야한다는 뜻이기도 하다. 응집도 Cohesion클래스 안의 함수와 변수가 서로 의존하며 논리적인 단위로 묶이는 것이 좋으며 이를 응집도가 높다고 이야기한다. ‘함수를 작게, 매개변수 목록을 짧게’ 전략을 따라가다 보면 몇몇 함수들만이 사용하는 인스턴스 변수가 많아지는데, 이 때가 응집도가 떨어지는 시기이며 클래스를 분리시켜야하는 지점이다.해당 파트에는 함수와 클래스를 쪼개면서 리팩토링하는 예제가 있는데 글로 모두 담기는 힘들어서 한 번씩 읽어보기를 바란다.🧹변경하기 쉬운 클래스예시로 설명을 해보자. 다음의 Sql 클래스는 변경이 필요해 리팩토링이 필요한 코드이다.public class Sql { public Sql(String table, Column[] columns); public String Select(); public String insert(Object[] fields); public String selectAll(); public String findByKey(String keyColumn, String keyValue); public String select(Column column, String pattern); public String select(Criteria criteria); // 이하 생략}만약 새로운 SQL 문을 지원하고자 코드를 반영한다면 반드시 Sql 클래스를 수정해야만 한다. 기존 SQL 문을 수정하려고해도 Sql 클래스를 수정해야한다. 이처럼 변경할 이유가 두 가지 이상이 될 수 있으므로 Sql 클래스는 SRP를 위반한다고 볼 수 있다. 그렇다면 아래와 같은 코드로 클래스와 함수를 분리한다면 어떻게 될까?abstract public class Sql { public Sql(String table, Column[] columns); abstract public String generate();}public class CreateSql extends Sql { public CreateSql(String table, Columns[] columns); @Overide public String generate();}public class SelectSql extends Sql { public SelectSql(String table, Columns[] columns); @Overide public String generate();}public class InsertSql extends Sql { public InsertSql(String table, Columns[] columns, Object[] fields); @Overide public String generate(); private String valuesList(Object[] fields, final Columns[] columns);}// 이하 생략이렇게 작성된 경우, 클래스들이 극도로 단순해지게 되며 코드를 이해하기 쉬워진다. 함수 하나를 수정해도 다른 클래스나 함수를 건드리는 경우도 없어서 위험성이 사라졌다. 또한, 새로운 SQL 문을 추가한다고 하더라도 Sql 클래스를 상속받는 새로운 UpdateSql 클래스를 생성하면 된다. 이러한 설계는 OCP 원칙도 준수하는데, 새로운 기능을 추가하더라도 기존의 클래스들은 변경할 필요가 없이 닫혀있다. 변경으로부터 격리요구사항은 변하고 코드도 변한다. interface와 abstract class를 활용함으로써 구현이 미치는 영향을 서로 격리할 수 있다.외부 API를 사용해서 진행하는 Portfolio 클래스가 있다고 하자. 해당 클래스에 외부 API를 바로 사용하는 것은 여러 원칙들에 어긋나며 변경으로부터 자유롭지 않다.외부 API를 사용하는 새로운 인터페이스와 클래스를 생성한 후, 해당 클래스를 Portfolio 클래스로 가져와서 사용하는 것이 테스트에도 유용하며 시스템의 결합도를 낮춘 유연성과 재사용성이 높은 코드라고 할 수 있다.결론이번 챕터들에서는 다양한 전략과 원칙, 규칙들이 언급되었다. 그만큼 기존에 제시된 가이드라인을 따르는 것이 중요함을 강조하는 챕터라고 생각이 되었고, SOLID 원칙과 GOF 패턴들을 다시 한 번 공부해보는 시간을 가져야겠다." }, { "title": "[Book] Clean Code - 4주차 (7장, 8장)", "url": "/posts/Book-CleanCode5/", "categories": "Backend, Books, Clean Code", "tags": "clea code, book", "date": "2023-10-02 01:00:56 +0900", "snippet": "오류 처리오류가 발생할 확률이 0이 되는 일은 존재하지 않는다. 오류 처리를 어떻게 하느냐에 따라 코드의 논리를 잘 드러내는지가 결정된다고 볼 수 있다.🧹오류 코드보다 예외를 사용하라앞선 챕터들에서도 몇 번 이야기가 나왔던 이야기이다. 오래된 언어들은 예외를 지원하지 않는 경우가 많았고 오류를 처리하고 보고하는 방법이 제한적이었기에 오류 코드를 사용했다. 하지만 Java의 Try-Catch-Finally 구문과 같이 Exception 처리를 지원하는 언어라면 해당 기능을 통해서 오류 처리와 기능 부분을 구분하도록 하자.// class 안의 함수들이다.public void sendShutDown(){ try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); }}private void tryToShutDown () throws DeviceShutDownError { // 논리 전개...}🧹Checked Exception VS Unchecked Exception확인 예외, 미확인 예외를 명확히 알지 못해 검색을 통해 찾아보았다. Checked VS Unchecked간단히 정리하자면 확인 예외는 반드시 try-catch를 통해서 오류 처리 코드를 작성해야하는 예외들이며, 비확인 예외는 RuntimeException의 범주에 속하는 예외들로 개발자에 의해 선택적으로 try-catch 구문을 작성할 수 있다. 확인 예외는 아래 코드와 같이 throws를 붙여줘야한다.public void test() throws IOException { // ...}초창기 자바는 확인 예외를 좋다고 여겼지만 현재는 Open-Closed Principle을 위반하는 문제가 있는 과정이라고 여긴다. 하위 단계 함수에서 예외를 throw한다면 해당 코드를 포함하는 모든 상위 단계 함수 선언부에 throws를 추가하여 수정해야한다.따라서, 확인 예외를 사용함으로써 모든 예외를 확인할 필요가 있는 경우를 제외하고는 일반적으로 Unchecked Exception의 사용을 권장한다.🧹호출자를 고려해 예외 클래스를 정의하라이 부분은 글을 읽어도 이해가 되지 않는 부분들이 존재해서 코드를 대부분 적어보려고 한다.ACMEPort port = new ACMEPort(12);try { port.open();} catch (DeviceReseponseException e) { reportPortError(e); logger.log(\"Device response exception\", e);} catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(\"Unlock exception\", e);} finally { // ...}호출해서 사용하는 외부 라이브러리 API가 존재한다면 아래와 같이 Wrapper Class를 통해서 예외를 작성하는 것이 더 좋다고 한다.// 사용 예시LocalPort port = new LocalPort(12);try { port.open();} catch (PortDeviceFailure e) { retportError(e); logger.log(e.geMessage(), e);} finally { // ...}// Wrapper Class 파일public class LocalPort { private ACMEPort innerPort; public LocalPort(it portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); } catch (DeviceReseponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } } // ...}Wrapper 클래스를 통해서 외부 라이브러리와 프로그램 사이의 의존성을 줄이며, 다른 라이브러리로 전환하기에도 용이하다고 한다.🧹정상 흐름을 정의하라try-catch 구문을 사용하지 않고도 진행할 수 있는지 확인해봐야한다.try { MealExpenses expenses = expenseReportDAO.getMeals(employeee.getID()); m_total += expenses.getTotal();} catch(MealExpensesNotFound e) { m_total += getMealPerDiem();}expenses.getTotal()에서 에러를 발생하는 대신 getMealPerDiem에 해당하는 기능을 수행하면 될 것이다. 또한, expenses에 null이 올 수도 있으므로 expenseReportDAO에는 항상 MealExpenses 객체를 반환하도록 수정해주어야한다. 이를 특수 사례 패턴(Special Case Pattern)이라고 하며 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이라고 한다.특수 사례 패턴 1특수 사례 패턴 2🧹null을 반환하지 마라바로 앞에서 이야기한 것처럼 메소드릐 반환 값이 null이 되는 경우 null 확인을 하지 않아서 발생하는 NullPointerException과 같은 문제가 매우 자주 발생할 수 있다. 따라서 되도록 null을 반환하지 않게, 오류가 발생하지 않도록 특수 사례 패턴의 적용을 고려해보자.List&lt;Employee&gt; employees = getEmployees();if(employees != null) { for(Employee e : employees) { totalPay += e.getPay(); }}만약 위 코드에서 getEmployees()라는 함수가 null 대신 Collections.emptyList()와 같이 비어있는 List를 반환한다면 if 문을 없애도 정상적으로 작동할 것이다. null을 전달하지 마라앞에서 이야기한 내용의 연장선이다. 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 것을 최대한 피하는 것이 좋다. 만약 어떤 이유로든 null의 전달을 허용한다면 해당 문제를 처리할 코드가 필요해지며 이는 클린하지 않은 코드가 될 확률이 높아질 것이다.결론이번 챕터에서는 코드를 통한 예제를 많이 가져왔다. 단순히 말로만 듣고 이해하기에는 어려운 부분들이 있어서 코드를 통해 어떤 부분에 문제가 있어서 사용해서는 안되는지 확인할 수 있었던 것 같다.null을 인수로 넣거나 반환하는 함수를 많이 사용했었고 관련된 문제들을 많이 겪어서 책의 조언에 따라 사용하지 않아야함을 상기하게 된 것 같다.경계해당 챕터에서는 외부 코드를 어떻게 클린하게 적용할 수 있을지에 대해서 이야기한다.🧹외부 코드 사용하기인터페이스 제공자들은 더 많은 고객층을 확보하기 위해 적용성을 최대한으로 넓히려고 한다. 반면, 사용자들은 자신의 요구에 더 집중된 인터페이스를 요구한다. 이러한 간격 사이에서 문제점들이 발생하고는 한다.그 예시로, java.util.Map이 있다. Map은 광범위한 기능을 제공한다. clear() 함수로 누구나 객체의 정보를 삭제할 수 있으며 저장을 위한 객체 유형을 제한하지 않는다.Map sensors = new HashMap();Sensor s = (Sensor)sensors.get(sensorId);이에 따라, Map이 반환하는 Object를 올바른 유형으로 바꿔주는 과정이 추가되어야하며 그 책임은 Map의 사용자에게 있다.Map&lt;String, Sensor&gt; sensors = new HashMap&lt;Sensor&gt;();Sensor s = sensors.get(sensorId);위 코드와 같이 사용할 수 있기는 하지만, “필요하지 않은 기능까지 제공한다”는 문제가 해결되지는 않는다.또한, 인터페이스도 변할 가능성이 있는 존재이기에 사용을 금지하는 시스템도 존재했다. 만약 인터페이스가 바뀐다면 바꿔야할 코드의 범위가 매우 광범위해질 것이다.public class Sensors { private Map sensors = new HashMap(); public Sensor getById(String id) { return (Sensor)sensors.get(id); }}위 코드처럼 Map의 사용을 특정 클래스를 통해서 제공함으로써 범위를 제안하는 방법도 있다. 반드시 캡슐화를 하라는 의미는 아니며 경계를 넘어다니면서 사용하는 것은 오류를 유발할 수 있으므로 자제하라는 뜻이다. 경계 살피고 익히기외부 코드를 프로젝트에 사용하기 위해서는 코드를 익히고 통합하는 작업을 거쳐야 한다. 하지만 이는 쉬운 작업이 아니며 학습 테스트를 통해서 진행하는 것이 합리적이다. 학습 테스트는 간단한 테스트 케이스를 통해서 실제로 작동하는 방식을 확인해보는 과정으로 테스트+구글링+공식문서를 통해서 API에 익숙해질 수 있도록 해보자. 학습 테스트는 공짜 이상이다학습 테스트는 API 전체를 배우는 것에 비해서 필요한 지식만 확보하는 손쉬운 방법이다. 이해도를 높여주며 투자하는 노력보다 얻는 성과가 크다. API의 새로운 버전이 나오더라도 기존에 만들어둔 테스트를 통해서 다르게 작동하는지를 1차적으로 확인할 수 있다.이러한 테스트 케이스가 없다면, 오래된 버전을 계속 사용하려는 유혹에 빠질 수 있다.🧹아직 존재하지 않는 코드를 사용하기경계는 앞서 설명한 내용들도 있지만 알지 못하는 영역에 대한 경계도 존재한다. 지식의 경계를 넘어선 코드는 작성하기 힘들며 일반적으로 프로젝트에서는 지식이 많은 부분에서 지식의 경계 쪽으로 코드를 작성해나간다. 팀 단위로 이루어진 프로젝트라면 경계 바깥 쪽은 오픈소스와 같이 외부의 코드를 이용하거나 다른 팀에서 작성하고 있을 것이다.Adapter 패턴을 사용한다면 개발자가 바라는 인터페이스를 구현하기 이전에 정의할 수 있으며 Adapter를 통해서 구현 후 발생하는 차이점들을 해결할 수 있다. 또한 Fake 클래스를 사용하면서 테스트를 진행할 수도 있게 된다. 깨끗한 경계경계에서는 변경과 같은 특별한 일들이 자주 일어난다. 경계에 위치하는 코드들은 깔끔히 분리되어야 하며 테스트 케이스를 통해 잘 관리되어야한다. 의존에 관한 문제도 외부 코드보다는 통제 가능한 팀의 코드에 존재하는게 좋다.결론학습 테스트, Adapter 패턴에 대해서 알게 되었고 규모있는 프로젝트들에서 이러한 방식의 장점을 몸소 체험해보고 싶다." }, { "title": "[Book] Clean Code - 3주차 (5장, 6장)", "url": "/posts/Book-CleanCode4/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-09-17 23:30:15 +0900", "snippet": "형식 맞추기이번 챕터는 내용들의 이해가 어렵지 않은 편이라 목록으로 쭉 나열하는 방식으로 진행해보려고 한다. 개념은 빈 행으로 분리하라import, 함수처럼 의미가 분리되는 구간에는 빈 행을 넣어주는 것이 좋다. 세로 밀집도 &amp; 수직 거리비슷한 개념끼리는 코드 상의 거리가 가까워야하며 개념 사이의 주석이나 빈 행은 최소화되는 것이 좋다. 가로 형식적당히 짧은, 한 줄에 많아도 120자 정도의 길이가 되었으면 좋겠다. 들여쓰기대부분의 도구에서 지원하는 들여쓰기를 적극 활용해라. 가짜 범위빈 while문이나 for문은 오해를 유발할 수 있으며 사용을 자제하는 것을 추천한다. 다만, 사용했을 경우 세미콜론을 새로운 행에 작성하는 방식을 추천한다. while (dis.read(buf, 0, readBufferSize)) != -1); 팀 규칙을 우선해라합의된 규칙을 무시하는 것만큼 잘못된 행동은 없다. 팀에 속한다면 팀의 규칙을 따라라. 코드 자체가 최고의 표준 문서가 되도록 해라.🧹프로젝트 소개해당 챕터에서 7개의 프로젝트에서 파일 길이에 대해서 소개해주는 부분이 있다. 모르는 프로젝트들이 몇몇 존재해서 알아보고자 조사를 해보았다. FitNesse간단히 설명하자면 오픈소스 인수 테스트 자동화 도구이다. Fit(Framework for integrated test)라는 테스팅 프레임워크를 사용하며 이해관계자(고객, 개발자)들의 협업을 돕는 것을 목표로 한다. testNGJUnit과 유사한 자바 테스트 프레임워크이다. Time and Money (tam)검색해보았으나 해당 이름에 맞는 프로젝트를 찾지 못했다. JDepend자바 패키지 의존성 분석 도구이다. 재사용 여부, 무한 반복 의존 관계와 같은 문제점들을 조사하고 분석해주는 도구이다. Ant풀네임은 Apache Ant로 Java 프로그램용 build 도구라고 한다. 유사한 프로젝트로는 Tomcat이 있다. 결론이번 챕터에서는 “(적어도 나로서는)”과 같은 표현을 사용하며 개발자마다 느끼는 바가 다를 수 있음을 알려주는 경우가 있었으며 저자의 의견이 강하게 드러나지 않았다. 또한 “세로로 짧게 써라”, “가로로 짧게 써라”, “팀의 규칙을 우선해라”처럼 일반적인 상황에서 크게 벗어나는 내용들이 별로 많지 않았다.intellij와 같은 도구에서 지원하는 형식 맞추기로도 충분히 형식 맞추기를 준수할 수 있다고 생각하며 팀 규칙을 따르는 것만으로도 이번 챕터는 충분히 커버할 수 있다고 생각한다.객체와 자료 구조🧹자료 추상화변수를 공개하지 않는 것은 변수에 의존하지 않게 만들기 위해서이다. 내부 작동, 변수들을 알지 않아도 추상적인 개념으로, 함수로 표현하는 것이 좋다.아무런 생각 없이 그저 클래스의 private 변수를 조회/설정하는 get/set 함수를 추가하는 것은 그리 좋은 방향이 아닐 것이다.🧹자료/객체 비대칭일반적으로 객체는 자료를 숨기며 자료를 다루는 함수만을 공개하고, 자료구조는 자료를 그대로 공개하며 별다른 함수를 제공하지 않는 경향이 있다. 이러한 특징은 절차 지향과 객체 지향에서도 드러난다.절차적인 코드에서 각 도형에 대한 클래스가 있고, 해당 도형들을 사용한 계산을 진행해주는 Geometry 클래스가 있다고 하자.public class Square { public Point topLeft; public double side;}public class Circle { public Pointer center; public double radius;}public class Geometry { public final double PI = 3.141592; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); }}새로운 도형을 추가하는 경우, Geometry의 모든 함수에 해당 도형에 관한 내용을 추가해주어야 한다. 반면, 도형의 둘레 길이를 계산해주는 함수를 추가하고 싶을 때 도형 클래스나 다른 함수를 수정해야하는 일은 일어나지 않는다.객체 지향적인 도형 클래스의 경우를 살펴보자.public class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; }}public class Circle implements Shape { private Point center; private double radius; private final double PI = 3.141592; public double area() { return PI * radius * radius; }}새로운 도형을 추가하는 경우, 다른 도형을 수정해야하는 일은 일어나지 않는다. 반면, 도형의 둘레 길이를 계산해주는 함수를 추가하고 싶을 때 모든 도형 클래스에 함수를 추가해주어야 한다.이처럼 상호 보완적인 특징이 존재하며 객체와 자료 구조는 비대칭, 양분된다. 장점절차적인 코드 : 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.객체 지향 코드 : 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 단점절차적인 코드 : 새로운 자료 구조를 추가하기 어렵다.객체 지향 코드 : 새로운 함수를 추가하기 어렵다.이러한 특성들을 고려하여 적절하게 사용할 수 있어야 한다.🧹디미터 법칙모듈(객체)은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙으로 앞서 이야기한 내용들과 맥락이 비슷하다.final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();다음과 같은 코드를 기차 충돌이라고 하며 일반적으로 조잡하다 여기진다고 한다. 다음과 같은 방식으로 개선하기를 권장한다.Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String outputDir = scratchDir.getAbsolutePath();자료 구조라면 디미터 법칙에 해당하지 않으며 다음과 같이 작성될 수 있을 것이다.final String outputDir = ctxt.options.scratchDir.absolutePath; 잡종 구조이렇게 절차지향과 객체지향을 혼란하게 사용하다보면 객체와 자료 구조를 동시에 사용하고 있는 잡종 구조가 탄생하기도 한다. 되도록 피하도록 하자.🧹자료 전달 객체일반적으로 DTO라고 부르는 자료 구조체이다.비공개 변수를 바탕으로 get/set 함수를 통해서 조작한다.글쓴이는 “일종의 사이비 캡슐화”라고 표현하며 공개 변수만으로 작동하는 자료 구조체와 비교해서 큰 이점이 없다고 이야기한다.결론객체는 동작을 공개하고 자료를 숨겨야한다.자료 구조는 동작 없이 자료를 노출한다.상황에 맞게 더 좋은 방식을 사용할 수 있는 개발자가 되도록 하자.마지막 부분에 get/set을 이용한 DTO가 그리 큰 이점이 존재하지 않는다고 보는 부분이 있었는데 본인은 일반적으로 getter를 사용해서 DTO를 작성해서 궁금증이 생겼다. 코드가 “클린”하다면 객체와 자료구조가 구분되므로 get/set을 사용하지 않아도 된다는 의견인지 궁금하다." }, { "title": "[Book] Clean Code - 2주차 (4장)", "url": "/posts/Book-CleanCode3/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-09-12 23:31:29 +0900", "snippet": "주석글쓴이는 코드로 의도를 표현하지 못해 사용하는 필요악이라고 주석을 설명한다. 하지만, 그 마저도 거짓말이 많아 믿기가 힘들다고 한다. 커지는 코드 속에서 주석을 유지보수하는 것은 현실적으로 불가능하다.해당 파트에서 작성하는 내용들은 주로 주석의 사용에 대해 비판적인 내용들이며 사용을 자제하기를 바라는 내용들로 구성되어있다.🧹나쁜 코드를 보완하는 주석나쁜 코드를 보완하는 주석이 좋다는 의미가 아니다. 코드에 주석을 다는 이유는 일반적으로 코드가 좋지 않아서이다.주석을 적을 시간에 코드를 다시 한 번 점검해보는 것이 좋을 것이다.🧹의미가 담긴 주석분명, 코드만으로 설명하기 힘든 경우가 존재한다. 하지만 대부분의 경우는 코드로 의미를 전달할 수 있다.// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))------------------------------------------if (employee.isEligibleForFullBenefits())두 문장 중 어느 쪽이 더 이해하기 쉬운가? 주석을 읽고 코드를 이해하는 것보다 코드를 통해서 바로 이해하는 것이 훨씬 좋다.🧹추천 : 좋은 주석몇몇 주석은 정말 필요하거나 유익하다. 이러한 사례를 아래에서 확인할 수 있다. 법적인 주석저작권, 소유권을 비롯하여 법적인 내용을 포함하는 주석. 좋고 나쁘고를 떠나서 몇몇 프로그램에서는 꼭 필요한 내용이다. 의도를 설명하는 주석코드의 이해를 도와주는 것을 넘어서 왜 이러한 함수를 사용하게 되었는지 문제 해결 방식에 대한 의도를 설명해주는 주석이 필요한 경우가 있다. 결과를 경고하는 주석어떠한 경우에 해당 함수를 사용해서는 안되는지, 사용한다면 어떤 위험성을 가지는지(Thread Safe와 같은) 알려주는 주석은 실수를 줄일 수 있다는 점에서 합리적이다. TODO 주석앞으로 할 일에 대해서는 TODO를 작성해두면 좋다. 물론, 이는 개발 과정에 작성하는 것이며 코드 완성 단계에서는 제거해야한다. 중요성을 강조하는 주석자칫 놓칠 수 있는 점들의 중요성을 강조하는 주석은 결과를 경고하는 주석과 마찬가지로 실수를 줄여주기도 한다. 공개 API와 Javadocs설명이 잘되어있는 공개 API를 위해서 Javadocs와 같은 내용을 작성하는 것이 좋다. 하지만, 역시 주석을 달 때에는 조심해서 작성해야한다.🧹비추천 : 나쁜 주석좋은 주석과 반대로 절대해서는 안되는 주석들에 대한 내용이다. 주절거리는 주석이름만 봐도 사용해서는 안될 것 같다. 생각없이, 의무감, 기계적으로 작성하는 주석은 시간낭비다. 주석을 적는다면 최선을 다해서 적자. 같은 이야기를 하는 주석코드를 통해서 얻을 수 있는 정보들을 주석으로 반복해서 적는 것은 생산성을 떨어뜨린다. 코드에서 얻을 수 있는 정보 이상의 내용을 주석으로 적도록 하자./** * 컨테이너와 관련된 Logger 구현 */protected Log logger = null; 오해할 여지가 있는 주석주석을 적으면 오해의 여지가 발생하며 잘못된 사용의 코드가 작성될 수 있다. 의무적 주석설명이 필요없다. 무성의하고 배려심 없는 주석은 없는게 좋다. 이력을 기록하는 주석코드 변경 로그 형식의 주석은 버전 관리 시스템이 존재하지 않았을 시절에 유효했던 내용들이다. 이제는 완전히 제거하고 사용하자. 전역 정보너무 넓은 범위의 정보를 주석에 담아서는 안된다. 주석을 적는 주위의 코드에 대한 정보를 주석으로 담아야한다. 비공개 API와 Javadocs앞선 좋은 주석 파트에서 나온 것처럼 공개 API에서의 정리된 Javadocs는 도움이 된다. 하지만 비공개 API의 경우는 그럴 필요가 없다.결론본인은 주석을 그렇게 많이 사용하는 편이 아니다. 팀프로젝트를 하는 경우에도 주석을 거의 달지 않는 편이며, 대부분의 코드 작성을 알고리즘 문제 해결을 위해 사용하여 문제 해결의 flow 정도만을 주석으로 적어두는 편이다.그렇기에 이번 챕터는 공감되거나 와닿는 부분이 그리 많지 않았다. 그럼에도 주석이라는 것을 신중히 사용해야함을 느꼈다." }, { "title": "[Book] Clean Code - 2주차 (3장)", "url": "/posts/Book-CleanCode2/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-09-12 23:20:21 +0900", "snippet": "함수🧹짧은 함수함수는 짧을 수록 읽기 좋은 경향을 가진다.하나의 함수가 10줄이 안되면 좋겠다고 필자는 이야기한다.그렇게 되면 중첩 구조가 생기는 경우나 들여쓰기가 많아지는 경우도 발생하지 않으며 읽고 이해하기 쉬워진다.🧹한 가지 일을 하는 함수 SOLID 원칙 중 단일 책임 원칙과 유사하다는 생각이 들었다.함수는 한 가지 일만 하도록 작성해야한다.한 가지 일이라는 것이 모호해지는 경우가 발생하는데 이는 하나의 일을 해결하는데 여러 단계가 필요할 때다. 더 이상 하나의 이름으로 줄일 수 있는 함수가 존재하지 않는다면 그함수가 하나의 단계가 되는 것이다.🧹하나의 함수, 하나의 추상화 수준void Test () {\tgetHtml();\tString pagePathName = PathParser.render(pagePath);\t~.append(\"\\n\");}추상화 수준은 클린 코드에서 제시하는 추상화의 정도를 측정하는 단계이다.getHtml()과 같이 어떻게 작동하는지 알 수 없으면 추상화 수준이 높다고 이야기하며.append(”\\n”);과 같이 알고 있거나 직관적일수록 추상화 수준이 낮다고 이야기한다.String pagePathName = PathParser.render(pagepath); 과 같은 코드는 추상화 수준이 중간이라고 할 수 있겠다.이러한 추상화 수준을 하나의 함수에서 섞어 사용하면 안된다는 것이다. 내려가기 규칙선언된 함수의 추상화 수준은 코드가 내려가면서 함께 내려가야한다.즉, 아래로 갈수록 함수 단위에서 raw code로 작성될 것이다.🧹Switch 문을 피하는 함수switch 구문은 작게 만들기 어려우며 한 가지 일을 하게 작성할 수 없다.해당 구문을 완벽히 배제하는 것은 불가능하므로 여러 방식을 통해서 숨기기도 한다.대표적인 예로, switch 구문을 추상 팩토리 방식에 숨겨 아무에게도 보여주지 않는 방식이 있다. 추상 팩토리 방식이 무엇인지 몰라 잠시 찾아보았다. 추상 팩토리💠 추상 팩토리(Abstract Factory) 패턴 - 완벽 마스터하기추상 클래스를 바탕으로 만들어진 팩토리 패턴을 추상 팩토리라고 한다.🧹서술적인 이름을 사용하는 함수이름이 조금 길어지더라도 여러 부가적인 설명없이 이해 가능한 함수 이름을 작성하도록 노력하자.앞선 규칙들을 지키면 이름을 떠올리기가 더 쉬워질 것이다.일관성 있게 단어를 사용하고 배치하도록 하자.🧹인수가 적은 함수인수가 적을 수록 좋으며 3개 이상은 되도록이면 피하도록 하자.인수는 함수를 이해하기 어렵게 만들며 테스트하기도 힘들어진다. 단항 형식인수로 전달한 대상이 변하는 경우(출력 인수)는 되도록이면 피하는 것이 좋다.차라리 함수의 반환 값을 통해서 대상의 값을 바꾸는 것이 좋다.// 해당 함수가 출력 인수를 사용하지 않으며 입력 인수를 사용하므로 더 권장하는 형태이다.StringBuffer transform(StringBuffer in){}// out 인수가 함수를 거치면서 값이 바뀌는 출력 인수로 해당 방식은 권장하지 않는다.void transform(StringBuffer out){} 플래그 인수필자가 “추하고 끔찍하다.”고 표현할 정도로 권장하지 않는다.부울 형태로 들어오는 플래그 인수의 존재는 해당 함수에서 여러 가지 일을 처리하겠다는 의미라고 해석할 수 있을 것이다. (참과 거짓. 최소 2가지 경우에 따라 다른 일을 진행하므로) 이항 함수함수의 인수가 하나 더 생기면 인수 간의 순서가 생기며 해당 순서를 지키지 않아서 발생하는 실수는 매우 자주 일어난다. 삼항 함수이항 함수보다 더 이해하기 어려워지며 그에 따라 발생하는 문제도 늘어난다.double calcuateCircleArea(double x, double y, double radius);// 아래와 같이 객체로 묶어서 넘기는 것도 하나의 방법이다.double calcuateCircleArea(Point center, double radius); 인수 목록String.format()처럼 인수의 수가 가변적인 경우도 있다.하지만 함수의 선언부를 보면 public String format(String format, Object… args); 와 같이 이항 함수의 형태를 취하고 있다. 동사나 키워드의미론적으로 의도와 어울리는 이름이 필요하다.// 두 예시 모두 아래 함수의 이름이 인수의 의미나 순서를 명확하게 드러내준다.write(name); writeField(name);assertEquals(expected, actual);assertExpectedEqualsActual(expected, actual);🧹부수 효과가 없는 함수함수의 기능이 이름에 명확히 드러나 있다면 예상치못한 부수 효과를 최대한 방지할 수 있을 것이다. 출력 인수일반적으로 함수에게 특정 입력값을 제공하기 위해서 인수를 사용한다.이를 입력 인수라고 칭하며, 인수가 함수의 결과값이 되는 경우를 출력 인수라고 한다.이러한 출력 인수는 피하는 것을 권장하며 상태의 변경이 필요한 경우는 함수의 객체 상태를 바꾸는 방식을 선택하기를 바란다.🧹명령과 조회가 분리된 함수함수는 명령과 조회 2개의 역할 중 하나만을 선택해야한다.즉, 하나의 함수는 객체 상태를 변경하거나 반환해야한다. 둘을 모두 수행하는 경우는 좋지 않다.명령과 조회를 동시에 하는 경우 다음과 같은 일이 발생한다.public boolean set(String attribute, String value);//...if (set(\"username\", \"unclebob\")){...}set이라는 함수를 실행한 결과가 왜 if문의 조건문에 있는지 이해하기 힘들다.조건문을 위한 함수와 set을 위한 함수를 분리해서 작성하도록 하자.🧹오류 코드보다 예외가 있는 함수오류 코드를 사용한다면 위에서 설명한 명령의 기능을 하는 함수가 조건문에 오게되는 경우가 발생한다.if (deletePage(page) == E_OK){...} try-catch 블록 분리하기try-catch 블록이 들여쓰기를 비롯하여 구조적 혼란을 가져오며 일반적 논리와 오류 처리를 뒤섞는다고 한다. 따라서, 별도의 함수로 분리할 수 있도록 하자.public void delete(Page page){\ttry{\t\tdeletePageAndAllReferences(page);\t}\tcatch (Exception e){\t\tlogError(e);\t}} 오류 처리도 하나의 작업, 기능이다.함수는 한 가지 작업만을 해야한다는 원칙으로 보았을 때, 오류를 처리하는 함수는 오직 오류만을 처리해야한다. 오류 코드의 의존성 자석오류 코드는 주로 하나의 파일(Error.java)에서 작성하고 관리되며 이는 다른 클래스에서 사용하는 경우 항상 import를 진행해야한다.오류 코드가 바뀌는 경우, 해당 파일을 import하는 모든 파일에서 재컴파일/재배치가 일어나며 이는 권장하지 않는 방식이다.🧹반복하지 않는 함수같은 알고리즘의 코드를 반복적으로 사용하는 것은 재사용성에서 문제가 생긴다. 해당 알고리즘을 수정해야하는 경우 모든 코드를 직접 수정해야한다.🧹참고 : 구조적 프로그래밍구조적 프로그래밍에서는 return은 하나뿐이며 break, continue 사용을 자제하며 goto의 사용을 절대적으로 금지한다.하지만, 필자는 목표와 규율은 이해하나 클린코드에서 이야기하는 작은 함수에서는 큰 의미가 없다고 본다.구조적 프로그래밍이 무엇인지 몰랐었는데 절차적 프로그래밍의 하위 개념이라고도 할 수 있다는 위키백과의 설명으로 이해할 수 있었다.🧹참고 : 함수 생성하기함수는 글짓기와 비슷하며 생각을 나열한 후 마음에 들지 않는 것을 계속 고쳐나갈 수 있다.한번에, 원하는 코드를 작성한 사람은 존재하지 않을 것이다.결론이번 챕터를 읽으면서 생각한 내용들을 정리하자면 다음과 같다. 추상화 수준이 섞이는 것을 조심하자 switch문을 최대한 피하고 숨기자 인수를 적게 사용하자 출력 인수, 플래그 인수는 절대 사용하지 말자 명령과 조회가 분리된 함수를 사용하자 try-catch 블록을 분리하자그 중에서도 가장 인상깊었던 내용은 4번에서 “플래그 인수는 절대 사용하지 말자”이다.클린코드 저자가 “추하고 끔찍하다”라고 표현한 부분이 있었는데 본인이 플래그 인수를 자주 사용하는 편이어서 조금 마음이 아팠다. 최대한 없앨 수 있도록 노력해봐야겠다." }, { "title": "[Book] Clean Code - 1주차 (0~2장)", "url": "/posts/Book-CleanCode1/", "categories": "Backend, Books, Clean Code", "tags": "clean code, book", "date": "2023-09-03 21:28:50 +0900", "snippet": "0. 들어가면서코드 작성 원칙, 패턴, 실기를 설명하는 파트.사례 연구를 통해 문제를 해결할 수 있는 코드로 바꾸는 연습 파트.모든 내용을 정리해서 코드 스멜, 휴리스틱과 같은 면으로 분석한 결과 파트.클린 코드 책은 위 3가지 파트로 구성되어있다고 한다.책을 읽으면서 내용을 단락별로 요약하고 해당 단락의 끝에 느끼거나 배운 점들에 대해서 간략히 적어보고자 한다.1. 깨끗한 코드일을 빨리 마무리하기 위해서 나쁜 코드를 어쩔 수 없이 작성한다고 이야기하지만 사실은 깨끗한 코드가 일을 더 빨리 끝낼 수 있다.깨끗한 코드의 정의는 광범위하지만 몇몇 사람들에 의해 다음과 같이 정의되고는 한다.비야네 스트롭스트룹 우아한, 보기에 즐거운 코드. 나쁜 코드를 작성하도록 유혹하지 않는 코드. 깨진 창문 효과에서 벗어난 코드. 철저한 오류처리가 되는 코드. 한 가지 목적에 집중하는 코드.그래디 부치 가독성이 좋은 코드. 명쾌한 추상화. 사실에 기반한 필요한 내용 중심.데이브 토마스 다른 사람이 고치기 쉬운 코드. 테스트 케이스가 존재하는 코드. 되도록이면 작은 크기의 코드. 문학적, 읽기 좋은 코드.마이클 페더스 주의 깊게 작성한 코드. 세세한 사항까지 꼼꼼하게 신경 쓴 깔끔하고 단정하게 정리한 코드.론 제프리스 중복을 피하는 코드. 하나의 기능만 수행하는 코드. 제대로 표현하는 코드. 작게 추상화된 코드.워드 커닝햄 읽고 이해하고 다음으로 넘어갈 수 있는 코드. 읽으면서 놀랄 일이 없고 머리를 쥐어짤 필요가 없는 코드. 명백하고 단순해 마음이 끌리는 코드.마무리보이스카우트 규칙(처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.)은 프로그래머들 사이에서도 유용하다.이처럼 깨끗한 코드는 사람마다 정의가 다를 수 있지만 이 책은 저자들이 생각한 깨끗한 코드를 소개하고 도입하기를 권장하는 책이다. 클린코드 책을 통해서 하나의 사례를 배우고 코드에 사용해보기를 고려해보는 시간이 되었으면 한다.2. 의미 있는 이름변수, 함수, 인수, 매개변수, 클래스, 패키지, 소스 파일, 디렉터리 등 아주 많은 곳에서 이름을 사용하고 있으며, 이름을 잘 짓는 것이 클린코드를 위한 하나의 방법이 될 수 있다.의도가 명확한 이름이름을 지었을 때 한번더 주의 깊게 생각해보자.해당 키워드(변수, 함수, 클래스와 같은 대상)의 존재 이유는? 수행 기능은? 사용 방법은?추가적인 주석없이도 이해할 수 있도록 작성하는 것이 좋다.“함수가 어떤 기능을 하는지, 리스트 자료형에 어떤 내용들이 들어있는지, 특정 상수 값이 어떤 의미를 지니는지, 리스트의 n번째 값이 어떤 것을 의미하는지”와 같이 의도를 이름에 담을 수 있도록 하자.그릇된 정보를 제외한 이름자료형, 컨테이너 유형을 이름에 넣지 않는 편이 바람직하며, 다른 사람들이 헷갈려할 수 있는 정보들을 이름에 담아서는 안된다.비슷한 이름(단어나 철자 한 두개만 달라서 구별하기 힘든 이름)을 사용하지 않는 것이 좋다.또한 유사한 개념을 가진 대상들은 유사한 표기법을 사용해서 이름을 작성하는 것이 좋다.의미 있게 구분한 이름더 깊게 생각하지 못해 단순한 방식으로 변화시킨 이름들(불용어, noise word)은 의미를 가지지 못한다.예를 들자면, class 대신 klass라는 이름을 사용하거나 name1, name2와 같이 연속적인 숫자로 구분하는 것이 있겠다. money와 moneyAmount라는 변수가 동시에 있다고 했을 때, 어떤 변수를 언제 써야할지 구분할 수 있겠는가?이러한 이름들은 정보를 제공하지도, 작성자의 의도를 드러내지도 않는다.발음하기 쉬운 이름인간은 언어에 익숙하기에 발음하기 쉬운 이름의 활용성이 더 높다.또한, 발음하기 어려운 이름은 다른 사람들과 이야기하기에도 불편해진다.검색하기 쉬운 이름광범위한 코드안에서 원하는 부분을 검색하기 위해서는 검색하기 쉬운 이름이 존재해야한다. 단일 문자나 상수로 표현되는 경우는 검색하기가 분명히 어렵게 될 것이다.예를 들어, 99라는 숫자와 PAGE_NUMBER라는 상수 중에 무엇이 더 검색하기 쉽겠는가.인코딩을 피하는 이름과거 제한된 언어에서는 헝가리식 표기법과 같이 이름에 다양한 정보를 접두어나 접미어로 표현해주었다.하지만 언어의 발달로 더이상 그러할 이유가 없을뿐더러 읽기에 불편한 방식을 유지할 필요가 없다.기억력이 필요없는 이름다른 사람이 코드를 읽으면서 이름을 다른 이름으로 변환해야하는 과정이 필요해서는 안된다.단일 문자로 변수를 만드는 경우가 그러할 것이다. 물론 짧은 루프처럼 범위가 작고 이름이 충돌하지 않는 선에서는 i, j, k와 같은 변수들을 사용해도 될 것이다. 하지만 대부분의 경우는 이러한 경우에 해당하지 않을 것이다.추천 : 클래스 이름Class, 객체의 이름은 명사나 명사구를 추천한다.Customer, Account와 같은 단어들은 좋지만 Manager, Processor, Data, Info와 같은 단어들은 피하고 동사를 사용하지 않는 것이 좋다.추천 : 메서드 이름메서디의 이름은 동사나 동사구가 적합하다.postPayment, deletePage와 같은 이름들이 좋으며 특징적인 몇몇 이름들은 get, set, is와 같은 동사로 시작하기도 한다.생성자를 중복정의하는 경우는 정적 팩토리 메서드를 사용한다고 한다. 아래 두 코드를 비교해보면 좋다.// 해당 코드가 생성자 인수로 어떤 내용이 전달되는지 알 수 있어 직관적이다.Complex fulcrumPoint = Complex.FromRealNumber(23.0);// 어떤 내용이 생성자 인수로 들어가게 되는지 알 수 없다.Complex fulcrumPoint = new Complex(23.0);기발하지 않은 이름일반적인, 명료한 이름을 사용하는 것이 좋다.구어체, 속어, 특정 문화에서 사용되는 언어, 농담 등은 피하는 것이 좋다.한 개념에 한 단어를 사용하기예를 들어, 어떤 정보를 가져오는 메서드를 fetch, retrieve, get으로 나눠 사용하는 것보다는 하나로 통일하는 것이 좋다.유사한 경우로 controller, manager, driver도 있을 수 있다.말장난하지 않는 이름기능이 다르다면 이름도 달라야한다.Class마다 add라는 메소드가 있다고 하면, add라는 메소드는 모두 의미론적으로 같은 기능을 수행해야한다.하지만 변수 둘을 더하는 의미의 add와 집합에 요소를 추가하는 의미의 add처럼 구분되는 경우가 발생한다면 두 메소드의 이름은 달라져야만 한다.해법 영역에서 가져온 이름해법 영역이라는 것은 동업자, 프로그래머들이 주로 사용하는 용어를 사용하라는 것이다.알지 못하는 고객 측의 문제 영역에서 이름을 가져오는 것보다 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용하라는 것이다.문제 영역에서 가져온 이름앞서 이야기한 해법 영역의 연장선이다.적절한 프로그래머 용어가 없다면 그때서야 문제 영역에서 이름을 가져오면 된다. 해법 영역과 문제 영역의 이름을 적절히 사용할 줄 아는 것이 프로그래머의 능력이며 이름의 기원이 어디에 더 관련이 깊은 지 파악해보자.의미 있는 맥락을 가지는 이름코드를 읽다보면 단어의 뜻은 있지만 어떤 맥락에서 사용되는지 헷갈리는 경우가 있다.이를 명확히하는 것이 중요하다.예를 들면, firstName, lastName, street, houseNumber, city라는 변수들이 있다고 할 때 각각의 변수들이 모여 주소를 나타내게 된다. 맥락 상으로 주소를 표현할 때 사용하는 변수들이므로 접두어로 addr과 같은 내용들을 붙여서 분명히 해줄 수 있다. addrFristName, addrStreet와 같이 말이다.불필요한 맥락을 없앤 이름앞서 이야기한 맥락에 대한 추가적인 이야기이다.이름이 전달하는 내용이 확실하다면 짧은 편이 좋다.예를 들자면, accountAddress와 cutomerAddress는 클래스 인스턴스로는 좋지만 클래스의 이름으로 사용하기는 힘들다. 그냥 Address라는 클래스 이름으로도 원하는 의미를 전달할 수 있을 것이다.포트 주소, MAC 주소, 웹 주소를 구분하는 경우는 PostalAddress, MAC, URI라는 이름으로도 충분히 원하는 내용을 이름에 담을 수 있을 것이다.마무리좋은 이름이라는 것은 이름을 사용하는 환경에 따라 결정된다.반복적이고 암기에 관한 영역은 도구에게 맡기고 꾸준히, 지속적으로 코드를 개선하려고 노력하는 것이 중요하다.이러한 지침들에는 당연하게도 추상적인 내용들이 많다. 모든 경우에 대해서 설명하기에는 그 내용이 방대하기 때문이다. 결국, 이렇게 제시된 조건들을 바탕으로 본인 스스로가 끊임없이 생각하고 이름을 결정하는 것이 중요한 것 같다." }, { "title": "[BOJ] 웜홀 - 1865 (java)", "url": "/posts/BOJ-1865/", "categories": "ProblemSolving, BOJ", "tags": "bellman-ford, 골드 3, java", "date": "2023-08-16 16:25:20 +0900", "snippet": "문제 코딩테스트 연습 - 웜홀풀이시간을 역행한다는 점에서 음의 간선이 있는 벨만포드 알고리즘을 이용하는 문제였고 문제에서 원하는 바는 음의 간선 순환의 존재 여부였다.처음에는 역시 n*n의 배열을 통해서 그래프를 그리고 문제를 진행하였으나 여러 번 실패하였다. 고민과 도움들을 바탕으로 문제를 해결하였고 문제를 실패한 이유에 대해 설명하자면 다음과 같다. 모든 정점끼리 연결되어있음이 보장되지 않는다.이는 하나의 정점에서 실행한 벨만-포드 알고리즘으로는 연결되지 않은 그래프에서 발생하는 음의 간선 순환을 확인할 수 없다는 뜻이다. 즉, 모든 정점에서 벨만-포드 알고리즘을 확인해봐야한다. 하지만 이는 다음 문제점으로 이어진다. 벨만-포드 알고리즘의 시간 복잡도는 O(n*m)이다.1번에서 설명한 내용대로 모든 정점에서 벨만-포드 알고리즘을 실행하면 시간 복잡도는 O(n*n*m)으로 문제를 해결하였다고 말하기 애매한 느낌이었다.이에 따라 나름 최선을 다하였지만 실패했고 다음의 게시글을 참고하여 문제 해결에 도움을 받을 수 있었다. 게시글 링크모든 정점을 방문하는 방법은 다음과 같았다. 모든 정점의 distance를 0으로 초기화하여 시작한다.의미론적으로 distance가 0으로 초기화된 정점이 시작점이라고 하였으므로 모든 정점의 시작값을 0으로 초기화해주면 된다. 가상의 n+1번째 정점을 추가한 뒤, 다른 모든 정점으로 0의 가중치로 이동하는 단방향 간선(해당 문제에서는 시간이 0인 웜홀이 될 것이다.)을 설치해준다.0의 가중치로 모든 정점에 도달할 수 있으므로 모든 정점을 방문하는 것이 가능하다.이 문제에서도 두 정점을 연결하는 도로가 여러 개 있을 수 있다고 하였는데, 해당 문제에서는 크게 고려할 사항이 아니었다. 앞선 문제의 경우에는 최단경로와 그 길이를 구하는 것이 핵심이었지만 해당 문제는 음의 간선 순환이 존재하는 지 여부가 핵심으로 정점과 간선 수에 따른 메모리 초과, 공간 부족 등을 고려하지 않아도 되었다.코드 public static void solve() throws IOException { t = Integer.parseInt(br.readLine()); for (int i = 0; i &lt; t; i++) { boolean checkContinue = false; String[] input = br.readLine().split(\" \"); n = Integer.parseInt(input[0]); m = Integer.parseInt(input[1]); int w = Integer.parseInt(input[2]); List&lt;Triple&lt;Integer, Integer, Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); int go, to, value; for (int j = 0; j &lt; m + w; j++) { input = br.readLine().split(\" \"); go = Integer.parseInt(input[0]); to = Integer.parseInt(input[1]); value = Integer.parseInt(input[2]); if (j &lt; m) { graph.add(new Triple&lt;&gt;(go, to, value)); graph.add(new Triple&lt;&gt;(to, go, value)); } else { graph.add(new Triple&lt;&gt;(go, to, -value)); } } bellmanFord(graph); } } public static void bellmanFord(List&lt;Triple&lt;Integer, Integer, Integer&gt;&gt; graph) { int[] distance = new int[n + 1]; Arrays.fill(distance, 0); for (int i = 1; i &lt; n; i++) { for (Triple&lt;Integer, Integer, Integer&gt; element : graph) { int go = element.first; int to = element.second; int value = element.third; if (distance[to] &gt; distance[go] + value) { distance[to] = distance[go] + value; } } } for (Triple&lt;Integer, Integer, Integer&gt; element : graph) { int go = element.first; int to = element.second; int value = element.third; if (distance[to] &gt; distance[go] + value) { distance[to] = distance[go] + value; print(\"YES\"); return; } } print(\"NO\"); }" }, { "title": "[BOJ] 최단경로 - 1753 (Java)", "url": "/posts/BOJ-1753/", "categories": "ProblemSolving, BOJ", "tags": "dijkstra, 골드 4, java", "date": "2023-08-14 14:44:13 +0900", "snippet": "문제 코딩테스트 연습 - 최단경로풀이방향 그래프에서 한 점에서 다른 모든 점까지의 최단거리를 구하는 문제이다.평소에 하는 것처럼 2차원 배열과 다익스트라 알고리즘을 통해서 구현했지만 메모리 초과에 걸렸다.이는 노드의 수가 최대 2만개로 2차원 배열을 통해서 해결할 수 없음을 의미했다.문제를 다시 자세히 읽어본 후, 두 정점을 이어주는 경로가 여러 개 있을 수 있음을 확인했고 최단 경로에 필요없는 경로들을 없애기위해 HashMap을 도입하여 정점간의 관계를 표현해주었다.코드 public static void solve() throws IOException { String[] input = br.readLine().split(\" \"); int v = Integer.parseInt(input[0]); int e = Integer.parseInt(input[1]); int start = Integer.parseInt(br.readLine()); //make graph with HashMap Map&lt;Integer, Character&gt;[] graph = new Map[v + 1]; for (int i = 1; i &lt;= v; i++) { graph[i] = new HashMap&lt;&gt;(); } for (int i = 0; i &lt; e; i++) { String[] input2 = br.readLine().split(\" \"); int from = Integer.parseInt(input2[0]); int to = Integer.parseInt(input2[1]); char value = (char) Integer.parseInt(input2[2]); if (!graph[from].containsKey(to)) { graph[from].put(to, value); continue; } graph[from].put(to, (char) Math.min(value, graph[from].get(to))); } int[] distance = djkstra(graph, start, v); for (int i = 1; i &lt;= v; i++) { if (distance[i] == INF) { System.out.println(\"INF\"); } else { System.out.println(distance[i]); } } } public static int[] djkstra(Map&lt;Integer, Character&gt;[] graph, int start, int v) { boolean[] visited = new boolean[v + 1]; int[] distance = new int[v + 1]; Arrays.fill(distance, INF); distance[start] = 0; visited[start] = true; // directed 간선 연결 graph[start].forEach((index, value) -&gt; { if (value == 0) return; distance[index] = value; }); while (true) { // distance 중 방문하지 않았고 값이 inf가 아닌 가장 작은 친구를 고른다. int min = INF; int minIndex = -1; for (int i = 1; i &lt;= v; i++) { if (!visited[i] &amp;&amp; distance[i] &lt; min) { min = distance[i]; minIndex = i; } } // 방문할 노드가 없으면 종료 if (minIndex == -1) break; // 해당 node를 방문하였을 때 값이 갱신되는 친구들이 있는 지 확인하고 갱신해준다. visited[minIndex] = true; // 즉, a to b라고 했을 때 // a node b 와 a b 중 뭐가 더 빠른지 비교 for (Map.Entry&lt;Integer, Character&gt; e : graph[minIndex].entrySet()) { int index = e.getKey(); char value = e.getValue(); if (value == 0) continue; if (distance[index] &gt; distance[minIndex] + value) { distance[index] = distance[minIndex] + value; } } } return distance; }" }, { "title": "[BOJ] 상어 초등학교 - 21608 (C++)", "url": "/posts/BOJ-21608/", "categories": "ProblemSolving, BOJ", "tags": "implement, 골드 5, cpp", "date": "2022-07-17 22:33:23 +0900", "snippet": "문제 코딩테스트 연습 - 상어 초등학교풀이네이버 부스트캠프 코딩테스트를 치루면서 구현 문제에 대한 연습이 필요함을 느꼈다. 별다른 알고리즘 없이도 문제가 어려울 수 있음을 느꼈고 구현에 관한 실력을 늘리기 위해서는 많이 풀어보는 수 밖에 없다고 생각했다.문제를 푸는 과정은 다음과 같다. 입력으로 들어온 학생에 대하여 현재 교실에서 가장 가치가 높은 자리를 찾아주고 거기에 자리를 정해준다. (goSeat함수) 그렇다면 가치가 높은 자리는 어떻게 찾는가?= 교실의 모든 자리의 가치를 확인해보고(getSeatValue함수) 가장 높은 자리를 찾을 수 있다. 그렇다면 좌표가 주어진 특정 자리의 가치는 어떻게 확인하는가?= 상하좌우를 살펴 그곳에 좋아하는 학생이 많이 앉아있는지, 빈자리가 많은지를 확인할 수 있고 좌표가 주어졌으므로 해당 자리의 행과 열의 가치 또한 확인할 수 있다.코드#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_SIZE 501#define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0);typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;pii, pii&gt; piii;// variablesint n, m, K, itemp1, itemp2;int dirY4[] = {-1, 0, 1, 0};int dirX4[] = {0, 1, 0, -1};// additional variables and functionsvector&lt;int&gt; favor_students[401];int satisfaction_value[] = {0, 1, 10, 100, 1000};int board[401][401] = { 0,};bool compareValue(piii max_value, piii cur_value){ if (max_value.first.first != cur_value.first.first) { return max_value.first.first &lt; cur_value.first.first; } if (max_value.first.second != cur_value.first.second) { return max_value.first.second &lt; cur_value.first.second; } if (max_value.second.first != cur_value.second.first) { return max_value.second.first &gt; cur_value.second.first; } return max_value.second.second &gt; cur_value.second.second;}piii getSeatValue(int y, int x, int studentId){ piii ret = piii(pii(0, 0), pii(y, x)); int i, j, nextY, nextX, value; // search 4 directions for (i = 0; i &lt; 4; i++) { nextY = y + dirY4[i]; nextX = x + dirX4[i]; if (0 &lt; nextY &amp;&amp; nextY &lt;= n &amp;&amp; 0 &lt; nextX &amp;&amp; nextX &lt;= n) { value = board[nextY][nextX]; // find favor for (j = 0; j &lt; 4; j++) { if (value == favor_students[studentId][j]) { ret.first.first++; break; } } // find blank if (value == 0) { ret.first.second++; } } } return ret;}void goSeat(int studentId){ int i, j; piii value; // piii = ((인접한 좋아하는 학생 수, 인접한 비어있는 칸의 수), (y좌표, x좌표)) piii max_value = piii(pii(0, 0), pii(n, n + 1)); // find max value seat for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { if (board[i][j] != 0) { continue; } value = getSeatValue(i, j, studentId); if (compareValue(max_value, value)) { max_value = value; } } } // go to seat board[max_value.second.first][max_value.second.second] = studentId;}void printResult(){ int i, j; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { cout &lt;&lt; board[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; }}int getSatisfaction(){ int i, j, k, l, studentId, cnt, nextY, nextX; int sum = 0; for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { studentId = board[i][j]; cnt = 0; for (k = 0; k &lt; 4; k++) { nextY = i + dirY4[k]; nextX = j + dirX4[k]; if (0 &lt; nextY &amp;&amp; nextY &lt;= n &amp;&amp; 0 &lt; nextX &amp;&amp; nextX &lt;= n) { for (l = 0; l &lt; 4; l++) { if (favor_students[studentId][l] == board[nextY][nextX]) { cnt++; break; } } } } sum += satisfaction_value[cnt]; } } return sum;}// main functionint main(){ // fastio; int i, j, k; // init cin &gt;&gt; n; int studentId; for (i = 0; i &lt; n * n; i++) { cin &gt;&gt; studentId; for (j = 0; j &lt; 4; j++) { cin &gt;&gt; itemp1; favor_students[studentId].push_back(itemp1); } sort(favor_students[studentId].begin(), favor_students[studentId].end()); goSeat(studentId); } cout &lt;&lt; getSatisfaction(); return 0;}" }, { "title": "[프로그래머스] 행렬 테두리 회전하기 - 77485 (C++)", "url": "/posts/Programmers-77485/", "categories": "ProblemSolving, Programmers", "tags": "implement, level2, cpp", "date": "2022-07-16 16:06:09 +0900", "snippet": "문제 코딩테스트 연습 - 행렬 테두리 회전하기 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이문제의 내용을 구현하는 문제이다. 행렬을 만들면 문제의 조건에 따라 i행 j열에 있는 숫자는 $((i-1) x columns + j)$이다. 이를 바탕으로 행렬 테두리 회전을 진행시켜주었다.자세한 구현은 아래와 같다. A 좌표와 B 좌표가 주어졌을 때 A가 좌측 최상단, B가 우측 최상단에 있는 도넛 모양의 행렬 테두리를 정의할 수 있다. 이 때 행렬 테두리 범위안에 있는 모든 좌표들을 시계방향으로 한 칸 씩 움직이려고 한다. 우선 A 좌표부터 시작하여 시계방향으로 나아가면서다음 좌표에 현재 좌표의 값을 넣어주면 된다. 물론 현재 좌표의 값은 회전하기 이전의 값이여야하므로 별도의 공간(itemp)에 잠시 저장해두는 방식을 사용하였다.$itemp=matrix[Pos_{next}]$$matrix[Pos_{next}]=matrix[Pos_{cur}]$$matrix[Pos_{cur}]=itemp$ 한 번의 회전을 진행하면서 건드리는 모든 값은 ans_value와 비교하여 최솟값을 저장해두며 query를 통한 회전 1번이 끝나면answer 배열에 최솟값을 저장해준다.코드#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;int board[101][101];void moving(int first_board, int second_board, int &amp;value, int &amp;ans_value);vector&lt;int&gt; solution(int rows, int columns, vector&lt;vector&lt;int&gt;&gt; queries){ vector&lt;int&gt; answer; int i, j, itemp; // set array for (i = 1; i &lt;= rows; i++) { for (j = 1; j &lt;= columns; j++) { board[i][j] = ((i - 1) * columns + j); } } // simulate query for (auto &amp;&amp;pos : queries) { pii first_pos = pii(pos[0], pos[1]); pii second_pos = pii(pos[2], pos[3]); int value = board[first_pos.first][first_pos.second]; int ans_value = 987654321; for (i = first_pos.second + 1; i &lt;= second_pos.second; i++) { moving(first_pos.first, i, value, ans_value); } for (i = first_pos.first + 1; i &lt;= second_pos.first; i++) { moving(i, second_pos.second, value, ans_value); } for (i = second_pos.second - 1; i &gt;= first_pos.second; i--) { moving(second_pos.first, i, value, ans_value); } for (i = second_pos.first - 1; i &gt;= first_pos.first; i--) { moving(i, first_pos.second, value, ans_value); } answer.push_back(ans_value); } return answer;}void moving(int first_board, int second_board, int &amp;value, int &amp;ans_value){ int itemp = board[first_board][second_board]; board[first_board][second_board] = value; value = itemp; ans_value = min(ans_value, value);}" }, { "title": "[프로그래머스] 단체사진 찍기 - 1835 (C++)", "url": "/posts/Programmers-1835/", "categories": "ProblemSolving, Programmers", "tags": "brute force, dfs, level2, cpp", "date": "2022-07-15 16:48:00 +0900", "snippet": "문제 코딩테스트 연습 - 단체사진 찍기 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이8명이 조건에 맞게 줄을 서는 경우의 수를 찾는 문제이다. 8명이 줄을 서는 모든 경우의 수는 8! == 40320, 약 4만개이다. 이는 완전탐색을 통해서 모든 경우의 수를 확인해볼 수 있다는 의미이다.따라서 makeGroup함수를 통해 8명이 줄을 서는 경우를 만들어주고 8명이 줄을 섰다면 입력으로 주어진 조건에 해당하는지 확인해준다. 입력을 통해 확인할 수 있는 정보는 2명의 friends 이름(firstMan, secondMan)과 그들 사이에 몇 명의 friends가 올 수 있는지(aimGap)에 관한 정보이다.2명의 friends 이름을 cpp의 string.find()함수로 현재 줄의 몇 번째에 서있는지를 알 수 있다. 이를 통해 현재 줄에서 두 사람 사이에 몇 명이 서있는지(gap)를 알 수 있고 aimGap과 비교하여 조건을 만족하는지 확인할 수 있다.조건을 모두 만족했다면 answer에 1을 더해주고 다음 경우로 넘어간다. 이는 재귀함수에서 1을 반환함으로써 구현해주었다.코드#include &lt;bits/stdc++.h&gt;using namespace std;bool isExisting[8];vector&lt;char&gt; names;int friendsToIndex(char c){ int i; for (i = 0; i &lt; 8; i++) { if (names[i] == c) { return i + 1; } }}int makeGroup(string group, int cnt, int &amp;n, vector&lt;string&gt; &amp;data){ int i; int ret = 0; if (cnt == 8) { for (i = 0; i &lt; n; i++) { char firstMan = data[i][0]; char secondMan = data[i][2]; char oper = data[i][3]; int aimGap = data[i][4] - 48; int firstIndex = group.find(firstMan); int secondIndex = group.find(secondMan); int gap = max(firstIndex, secondIndex) - min(firstIndex, secondIndex) - 1; if ((oper == '=' &amp;&amp; gap != aimGap) || (oper == '&lt;' &amp;&amp; gap &gt;= aimGap) || (oper == '&gt;' &amp;&amp; gap &lt;= aimGap)) { return 0; } } return 1; } for (i = 0; i &lt; 8; i++) { if (!isExisting[i]) { isExisting[i] = 1; ret += makeGroup(group + names[i], cnt + 1, n, data); isExisting[i] = 0; } } return ret;}// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.int solution(int n, vector&lt;string&gt; data){ int i; int answer = 0; for (i = 0; i &lt; 8; i++) { isExisting[i] = 0; } names = {'A', 'C', 'F', 'J', 'M', 'N', 'R', 'T'}; answer = makeGroup(\"\", 0, n, data); return answer;}" }, { "title": "[프로그래머스] 카카오프렌즈 컬러링북 - 1829 (C++)", "url": "/posts/Programmers-1829/", "categories": "ProblemSolving, Programmers", "tags": "bfs, level2, cpp", "date": "2022-07-14 16:01:17 +0900", "snippet": "문제 코딩테스트 연습 - 카카오프렌즈 컬러링북 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이별다른 조건이 없는 bfs 문제이다. bfs를 통해 최대 영역 크기를 구할 수 있고, bfs를 몇 번 실행하는지에 따라 전체 영역의 갯수를 구할 수 있다.bfs를 진행할 때 해당 칸이 빈칸이 아니고 현재 진행중인 bfs 영역의 색과 같은지를 확인해주면서 진행해주면 문제를 해결할 수 있다.프로그래머스의 문제들은 전역변수 사용시 반드시 함수안에서 초기화 작업을 진행해줘야한다. 아래 코드에서는 따로 적지는 않았지만 문제를 제출하려한다면 초기화 작업을 하기를 바란다.코드#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;bool visited[101][101] = { 0,};int dirY[4] = {-1, 0, 1, 0};int dirX[4] = {0, 1, 0, -1};int bfs(int y, int x, int &amp;m, int &amp;n, vector&lt;vector&lt;int&gt;&gt; &amp;picture){ int i; int cnt = 0; int cur_value = picture[y][x]; queue&lt;pii&gt; q; q.push(pii(y, x)); while (!q.empty()) { pii front = q.front(); q.pop(); int frontY = front.first; int frontX = front.second; if ((-1 &lt; frontY &amp;&amp; frontY &lt; m &amp;&amp; -1 &lt; frontX &amp;&amp; frontX &lt; n) &amp;&amp; !visited[frontY][frontX] &amp;&amp; picture[frontY][frontX] == cur_value) { visited[frontY][frontX] = 1; cnt++; for (i = 0; i &lt; 4; i++) { q.push(pii(frontY + dirY[i], frontX + dirX[i])); } } } return cnt;}vector&lt;int&gt; solution(int m, int n, vector&lt;vector&lt;int&gt;&gt; picture){ int number_of_area = 0; int max_size_of_one_area = 0; int i, j; for (i = 0; i &lt; m; i++) { for (j = 0; j &lt; n; j++) { if (!visited[i][j] &amp;&amp; picture[i][j] != 0) { int itemp = bfs(i, j, m, n, picture); max_size_of_one_area = max(max_size_of_one_area, itemp); number_of_area++; } } } vector&lt;int&gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer;}" }, { "title": "[프로그래머스] 네트워크 - 43162 (C++)", "url": "/posts/Programmers-43162/", "categories": "ProblemSolving, Programmers", "tags": "bfs, level3, cpp", "date": "2022-07-13 14:42:37 +0900", "snippet": "문제 코딩테스트 연습 - 네트워크 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이간선으로 연결된 네트워크의 갯수를 구하는 문제이다.모든 노드의 방문 여부를 기록하는 1차원 bool형 배열 visited를 통해 모든 노드들을 확인할 수 있다.모든 노드를 확인하면서 만약 해당 노드가 방문되지 않은 노드라면 bfs를 통해 해당 노드와 연결된 네트워크 전체를 확인해준다. 따라서 bfs를 통해 만나는 노드들은 모두 방문처리를 해준다. 해당 네트워크는 새로운 네트워크이므로 answer를 1 증가시켜준다.모든 노드를 방문했다면 answer의 값 만큼 네트워크의 개수가 있음을 확인할 수 있다.코드#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;bool visited[201] = {0,};void bfs(int start, int &amp;n, vector&lt;vector&lt;int&gt;&gt; &amp;computers){ int i; queue&lt;int&gt; q; q.push(start); while(!q.empty()){ int front = q.front(); q.pop(); if(!visited[front]){ visited[front] = 1; for(i=0;i&lt;n;i++){ if(computers[front][i] == 1){ q.push(i); } } } } return;}int solution(int n, vector&lt;vector&lt;int&gt;&gt; computers) { int answer = 0; int i; for(i=0;i&lt;n;i++){ if(!visited[i]){ answer++; bfs(i, n, computers); } } return answer;}" }, { "title": "[프로그래머스] 소수찾기 - 42839 (C++)", "url": "/posts/Programmers-42839/", "categories": "ProblemSolving, Programmers", "tags": "greedy, recursion, level2, cpp", "date": "2022-07-12 15:13:07 +0900", "snippet": "문제 코딩테스트 연습 - 소수찾기 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이주어진 숫자들을 1개 이상 조합하여 만들 수 있는 소수의 갯수를 구하는 문제이다.문제에서 필요한 내용은 2가지이다. 조합을 통해 어떤 숫자들을 만들 수 있는가 그 숫자들이 소수인가1)의 내용은 재귀함수를 통해 모든 경우를 조합해서 set에 중복없이 저장해두기로 하였으며,2)의 내용은 에라토스테네스의 체를 통해 7자리 이하의 모든 숫자들이 prime인지를 확인해주었다.set에 있으며 prime인 숫자들의 갯수를 세어서 answer로 return해주면 문제를 해결할 수 있다.코드#include &lt;bits/stdc++.h&gt;using namespace std;bool visited[7];set&lt;int&gt; ans;bool isNotPrime[10000000] = { 0,};void func(int index, string str, int select, int numbers_size, string &amp;numbers){ int i; if (index == numbers_size) { ans.insert(stoi(str)); return; } for (i = 0; i &lt; numbers_size; i++) { if (!visited[i]) { visited[i] = 1; func(index + 1, str + numbers[i], select + 1, numbers_size, numbers); visited[i] = 0; } else { func(index + 1, str, select, numbers_size, numbers); } }}int solution(string numbers){ int answer = 0, i, j; for (i = 2; i &lt; 10000000; i++) { if (!isNotPrime[i]) { for (j = i + i; j &lt; 10000000; j += i) { isNotPrime[j] = 1; } } } func(0, \"\", 0, numbers.size(), numbers); for (auto value : ans) { if (value &gt; 1 &amp;&amp; !isNotPrime[value]) { answer++; } } return answer;}" }, { "title": "[프로그래머스] 타겟 넘버 - 43165 (C++)", "url": "/posts/Programmers-43165/", "categories": "ProblemSolving, Programmers", "tags": "dfs, level2, cpp", "date": "2022-07-11 17:55:46 +0900", "snippet": "문제 코딩테스트 연습 - 타겟 넘버 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이숫자들의 배열이 주어졌을 때 +와 -를 적절히 사용하여 원하는 숫자를 만드는 경우의 수를 찾는 문제이다.주어진 배열의 길이가 최대 20이므로 +와 -를 이용한 모든 경우의 수는 2^20개, 약 100만개이며 이는 완전탐색을 통해 해결이 가능하다. 따라서 모든 경우를 진행하면서 해당 경우가 목표 숫자(target)과 일치하면 반환값에 1을 더해준다. 최종으로 반환되는 값이 target을 만들 수 있는 경우의 수가 되며 정답이라고 할 수 있다.코드#include &lt;bits/stdc++.h&gt;using namespace std;int dfs(int value, int index, vector&lt;int&gt; &amp;v, int &amp;target){ if(index == v.size()){ if(value == target){ return 1; } return 0; } return dfs(value+v[index], index+1, v, target)+dfs(value-v[index], index+1, v, target);}int solution(vector&lt;int&gt; numbers, int target) { return dfs(0, 0, numbers, target);}" }, { "title": "[프로그래머스] 프린터 - 42587 (C++)", "url": "/posts/Programmers-42587/", "categories": "ProblemSolving, Programmers", "tags": "priority queue, queue, level2, cpp", "date": "2022-07-10 15:08:23 +0900", "snippet": "문제 코딩테스트 연습 - 프린터 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이우선순위 큐, 그리고 일반적인 큐를 사용하는 문제이다.1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다.“대기목록의 가장 앞에 있는 문서(J)”에서 큐를, “대기목록에서 J보다 중요도가 높은 문서”에서 우선순위 큐를 생각할 수 있다. 둘을 활용하는 문제임을 알면 해결할 수 있는 문제였다. 배열로 주어진 인쇄 대기목록을 큐와 우선순위 큐로 만들어준다.큐를 통해 대기목록의 가장 앞에 있는 문서를 확인할 수 있으며 우선순위 큐를 통해 대기목록에서 중요도가 가장 높은 문서를 확인할 수 있다. 큐에서 문서를 하나씩 빼면서 해당 문서가 중요도가 가장 높은 문서인지 내가 원하는 문서인지를 확인한다. (우선순위 큐의 top과 비교, 입력으로 들어온 location값과 비교) 2)의 조건에 따라 3개의 경우가 생기는데 중요도가 높지 않은 문서, 중요도가 높지만 원하지 않는 문서, 중요도가 높으며 원하는 문서로 나뉜다. 중요도가 높지 않은 문서는 다시 큐에 넣어주고 큐의 다음 front에 있는 문서를 확인해주면 된다. 중요도가 높지만 원하지 않는 문서는 프린트되므로 answer의 값을 1 증가시켜준다. 해당 문서가 큐에서 사라졌으므로 우선순위 큐의 top 또한 pop시켜준다. 중요도가 높으며 원하는 문서가 나오면 나머지 큐들을 확인해줄 필요가 없으므로 answer를 return해주고 종료해주면 된다.코드#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;struct comp{ bool operator()(pii a, pii b) { return a.second &lt; b.second; }};int solution(vector&lt;int&gt; priorities, int location){ int answer = 1, i; priority_queue&lt;pii, vector&lt;pii&gt;, comp&gt; pq; queue&lt;pii&gt; q; for (i = 0; i &lt; priorities.size(); i++) { pq.push(pii(i, priorities[i])); q.push(pii(i, priorities[i])); } while (!q.empty()) { pii front = q.front(); q.pop(); if (front.second == pq.top().second) { if (front.first == location) { break; } answer++; pq.pop(); continue; } q.push(front); } return answer;}" }, { "title": "[프로그래머스] 멀쩡한 사각형 - 62048 (C++)", "url": "/posts/Programmers-62048/", "categories": "ProblemSolving, Programmers", "tags": "gcd, level2, cpp", "date": "2022-07-09 22:53:19 +0900", "snippet": "문제 코딩테스트 연습 - 멀쩡한 사각형 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이$w*h$크기의 직사각형이 있을 때 전체 블럭 갯수에서 가장 왼쪽 위의 점과 가장 오른쪽 아래의 점을 이은 대각선과 만나는 블럭의 갯수( $hit_{w,h}$ )를 빼주면 되는 문제이다.문제를 보던 중 GCD를 이용해 문제의 경우를 줄일 수 있음을 알았고 아래와 같이 가정해줄 수 있다. $g=GCD(w, h)$ $x=w/g$ $y=h/g$ $hit_{w,h}= g*hit_{x, y}$gcd는 알고 있는 지식에서 해결할 수 있으므로 $hit_{x, y}$에 관한 식만 구하면 문제를 해결할 수 있다. 하지만 해당 식을 계산하는 방법을 구하지 못해서 시간이 오래 걸렸다.대각선의 직선 경로는 가장 왼쪽 위의 점과 가장 오른쪽 아래의 두 점을 이어주는 최단 경로이다. 이를 블럭의 단위로 생각해본다면 가장 왼쪽 위의 블럭에서 출발하여 가장 오른쪽 아래의 블럭으로 가는 최단 경로로 나타낼 수 있다. 따라서 최단 경로의 길이는 $(가로+세로-1)$ 즉, $(x+y-1)$개이다.$hit_{x, y}=x+y-1$이므로 $hit_{w,h}=w+h-g$라고 할 수 있으며$answer=w*h-(w+h-g)$가 된다.코드#include &lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b) { if (b == 0){ return a; } return gcd(b, a % b);}long long solution(int w,int h) { return (long long)w * h - (w + h - gcd(w, h));}" }, { "title": "[프로그래머스] 디스크 컨트롤러 - 42627 (C++)", "url": "/posts/Programmers-42627/", "categories": "ProblemSolving, Programmers", "tags": "priority queue, level3, cpp", "date": "2022-07-08 20:54:17 +0900", "snippet": "문제 코딩테스트 연습 - 디스크 컨트롤러 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이heap을 이용한 문제이다. 푸는 방식에 대해서는 알았지만 코드로 구현하는 과정에서 꼬여서 많이 복잡해졌다. 풀이는 다음과 같다. 입력 배열이 정렬되지 않았으므로 jobs[i][0]에 대해서 오름차순으로 정렬해준다. (요청 시각이 짧은 순으로 정렬) 현재 처리 중인 요청이 끝날 때까지 들어오는 모든 요청을 priority queue에 넣어준다. priority queue는 jobs[i][1]이 작은 값이 top에 오게 된다. (처리 시간이 작은 순으로 정렬) 만약 priority queue가 비었다면 다음 요청 시각까지 들어오는 모든 요청을 priority queue에 넣어준다.이 부분을 놓쳐서 코드가 복잡해졌는데 만약 (0, 1)요청의 처리가 끝나고 같은 시각에서의 요청 (3, 6), (3, 7)이 들어왔을 때 이 둘 모두를 priority queue에 넣어주어야한다. priority queue의 top에 있는 요청을 처리하고 있음을 반영하기 위해 현재 처리 중인 요청이 끝나는 시각을 저장해준다. 다음 요청을 확인하며 2)로 돌아간다.개선할 점해당 문제의 경우, 코드를 작성하면서 하나의 논리를 놓쳐 다른 방식으로 구현하다 반복적으로 틀리는 경우였다. 무엇이 필요한지(현재 작업 중인 요청이 끝나는 시각, 다음 요청), 필요한 것을 제공하기 위해서 어떤 논리, 방식을 사용할지(priority queue의 empty여부에 따라 끝나는 시각을 다르게 설정, priority queue에서 다음 요청 뽑아냄)를 꼼꼼하게 생각해보고 진행하도록 하자.코드#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;struct comp_pq{ bool operator()(pii a, pii b) { return a.second &gt; b.second; }};bool comp_sort(pii a, pii b){ return a.first &lt; b.first;}int solution(vector&lt;vector&lt;int&gt;&gt; jobs){ int answer = 0; priority_queue&lt;pii, vector&lt;pii&gt;, comp_pq&gt; pq; vector&lt;pii&gt; jobs_pii; int i; int job_size = jobs.size(); // set and sort for (auto job : jobs) { jobs_pii.push_back(pii(job[0], job[1])); } sort(jobs_pii.begin(), jobs_pii.end(), comp_sort); int cnt = 0; int end_time = 0; int index = 0; while (cnt &lt; job_size) { while (index &lt; job_size &amp;&amp; jobs_pii[index].first &lt;= end_time) { pq.push(jobs_pii[index++]); } if (pq.empty()) { end_time = jobs_pii[index].first; continue; } pii top = pq.top(); pq.pop(); end_time += top.second; answer += end_time - top.first; cnt++; } return answer / job_size;}" }, { "title": "[Backend] 기초 개념 정리 - API", "url": "/posts/Backend-API/", "categories": "Backend, basic concept", "tags": "api", "date": "2022-07-07 22:38:55 +0900", "snippet": "API란정의 Application Programming Interface의 줄임말이다.Application : API를 이야기할 때의 application은 고유한 기능을 가진 모든 소프트웨어를 의미한다.Interface : 두 application 간의 서비스 계약(연결의 매개체)을 의미한다. 계약은 요청(request)와 응답(response)를 사용하며 application끼리 통신하는 방법에 대해 정의한다.즉 여러 개의 소프트웨어끼리 요청과 응답을 통해 통신하는 것을 의미한다고 할 수 있다.API의 4가지 방식 SOAP(Simple Object Access Protocoal) API단순 객체 접근 프로토콜(SOAP)을 사용하며 xml(다목적 마크업 언어 중 하나)을 사용하여 메시지를 교환한다.과거에 자주 사용되었으며 유연성이 떨어진다. RPC(Remote Procedure Call) APIxml을 사용하는 방식에서 JSON으로 넘어가는 과정에서 SOAP API의 대안으로 인식되었다고 한다.API의 재사용성이 떨어진다는 단점이 있다. Websocket APIJSON객체를 사용하여 데이터를 전달한다. 클라이언트와 서버 간의 양방향 통신을 지원한다.서버가 클라이언트에 콜백 메시지를 전송할 수 있다는 점에서 REST API 보다 효율적이라고 한다. REST(REpresentational State Transfer) API오늘날 가장 많이 사용되는 API라고 할 수 있다.클라이언트가 서버에 요청을 보내고 서버가 요청을 받아 함수를 통해 얻은 결과를 클라이언트에 응답으로 보내준다. REST APIHTTP APIHTTP는 HyperText Transfer Protocol의 줄임말로 다양한 파일을 전송하기 위한 방법이다.대부분의 API가 HTTP API이며 HTTP 통신 규칙을 이용하는 API를 지칭한다.IoT처럼 저사양, 저전력 환경에서 작동해야하는 장치는 HTTP 통신이 아닌 다른 프로토콜을 사용하기도 한다.REST를 위한 6가지 제한 조건 Client-Server architecture Client-Server 디자인 패턴을 통해서 관심사 분리(Separation of Concerns 줄여서 SoC) 디자인 원칙을 준수하며 진행할 수 있다.Client는 서비스 요청자, Server는 서비스 자원의 제공자이며 역할에 따라 작업을 분리해줄 수 있다. Statelessness 서버는 클라이언트의 요청에 대한 정보를 저장하지 않는다. 따라서 클라이언트에서 보내는 모든 요청은 서로 독립적이다. 추가적인 저장을 진행하지 않는다는 점에서 서버의 부하를 줄일 수 있고 서버 디자인을 단순하게 만들어준다.하지만 저장하는 정보가 줄어든만큼 모든 요청에 추가적인 정보가 들어가게 된다. Cacheability Statelessness가 서버에서의 추가 정보 저장에 관한 내용이었다면 Cacheability는 클라이언트의 정보 저장에 관한 내용이다. Cache는 서버의 지연을 줄이기위해서 여러가지 파일들을 클라이언트 측에서 임시로 저장해두는 방식이다.이를 통해 서버와의 추가적인 통신을 제거할 수 있으며 확장성과 성능을 향상시킬 수 있다. Layered system서버와 클라이언트 2개의 사이에 여러개의 중간 서버를 넣음으로써 서버에 가해지는 부하를 분산시킬 수 있으며 공유 캐시를 제공하여 확장성을 향상시킬 수 있다. 보안 로직을 비지니스 로직과 분리하여 다른 layer로 만들 수 있다. Code on demand(optional)Java applet이나 JavaScript를 통해서 서버에서 클라이언트의 기능을 확장시킬 수 있다. Uniform Interface통일된 형식의 인터페이스는 단순화 및 분리를 통한 독립적인 활용이 가능하다는 점에서 RESTful한 환경에 필수적이다. 여기서 Uniform Interface에 대한 4가지 제약 조건이 있는데 이는 HTTP API와의 차이점이라고도 할 수 있다. REST API에는 있으며 HTTP API에는 없다. Request를 통한 자원 식별Request에 있는 내용을 통해서 Resource를 파악할 수 있어야한다. Request를 통한 자원 변경특정 Request를 통해서 Resource를 변경, 삭제할 수 있어야한다. 자기서술적 RequestRequest는 스스로의 처리 방식에 대한 충분한 정보를 가지고 있어야한다. Hypermedia As The Engine Of Application State(HATEOAS)클라이언트가 원하는 어떤 Resource와 연관된 내용들을 Response에서 확인할 수 있어야한다. 즉 현재 사용 가능한 다른 리소스에 대한 하이퍼링크나 Hypermedia 정보가 Response에 있어야한다. 장점 통합정해진 형식으로 통신하기에 새로운 application과 기존 시스템의 통합이 유리하다. 혁신다양한 사회적, 기술적 혁신을 코드에 적용하여 배포하는데 큰 변화를 줄 필요가 없다. 확장고객의 요구 사항에 따라 프로그램의 전체 구조를 바꾸는 것이 아니라 API를 추가하는 선에서 다양한 확장이 일어날 수 있다. 유지 관리두 시스템 간을 이어주는 장치이므로 쉽게 바꿀 수 없다. 따라서 어느 한쪽의 변화가 다른 시스템에 영향을 주지 않도록 해준다. ReferenceAPI란 무엇인가요? - API 초보자를 위한 가이드 - AWSREST - 위키백과, 우리 모두의 백과사전API - 위키백과, 우리 모두의 백과사전" }, { "title": "[프로그래머스] 정수 삼각형 - 43105 (C++)", "url": "/posts/Programmers-43105/", "categories": "ProblemSolving, Programmers", "tags": "dp, cpp, python", "date": "2022-07-07 14:58:56 +0900", "snippet": "문제 코딩테스트 연습 - 정수 삼각형 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이파스칼의 삼각형과 비슷하면서 dp를 사용해 해결한 문제이다. 삼각형의 가장 윗 꼭대기에서 아래로 내려오는 경로에 있는 값의 합이 최대가 되는 값을 찾는 문제이다. 풀이는 다음과 같다. 높이가 k인 삼각형의 모든 가로 열에 대해 가장 위에 있는 열을 0번 열, 가장 아래에 있는 열을 k-1번 열이라고 하자. 인덱스 i, j에 대하여 i번째 열의 j번째 위치로 올 수 있는 경로 P(i, j)는 문제에서 주어진 바에 따라 P(i-1, j-1) 또는 P(i-1, j)에서 오는 경로 뿐이다. 결국 두 경로 중에 하나를 선택해야하는데 선택의 기준을 현재까지 지나온 경로의 합이 가장 큰 경로로 정하면 된다. 경로를 선택하고 나면 현재 위치의 경로 값을 더해서 저장해주면 된다. 따라서 $P(i, j) = max( P( i-1, j-1 ), P( i-1, j ) )+ value(i, j)$ 가 된다. 두 경로 중에 하나가 없는 경우에는 다른 한 쪽 경로를 바로 선택해주면 된다. 0번째 열부터 마지막 열까지 계산을 끝내면 k-1번째 열에는 해당 위치로 올 수 있는 경로의 최댓값이 저장된다. 따라서 이들 중에서 가장 큰 값을 찾아 answer에 저장해주면 된다.코드#include &lt;bits/stdc++.h&gt;using namespace std;int P[500][500] = {0,};int solution(vector&lt;vector&lt;int&gt;&gt; triangle) { int answer = 0; int i, j; int left, right; P[0][0] = triangle[0][0]; for(i=1;i&lt;triangle.size();i++){ for(j=0;j&lt;triangle[i].size();j++){ left=P[i-1][j-1]; right=P[i-1][j]; if(j==0){ P[i][j] = right+triangle[i][j]; continue; } if(j==triangle[i].size()-1){ P[i][j] = left+triangle[i][j]; continue; } P[i][j] = max(left, right)+triangle[i][j]; } } answer = *max_element(P[triangle.size()-1], P[triangle.size()-1]+triangle[triangle.size()-1].size()); return answer;}" }, { "title": "[프로그래머스] 모의고사 - 42840 (C++)", "url": "/posts/Programmers-42840/", "categories": "ProblemSolving, Programmers", "tags": "greedy, cpp, level1", "date": "2022-07-06 23:56:28 +0900", "snippet": "문제 코딩테스트 연습 - 모의고사 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이3명의 참가자가 있는데 참가자가 문제를 찍는 방식이 정해져있다.따라서 배열에 저장하여 문제 번호마다 꺼내쓰는 방식으로 하였다.모든 문제를 풀었을 때 가장 높은 점수와 일치하는 참가자들을 answer vector에 넣어주고 오름차순으로 정렬해주면 된다.코드#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; fir = {1, 2, 3, 4, 5};vector&lt;int&gt; sec = {2, 1, 2, 3, 2, 4, 2, 5};vector&lt;int&gt; thr = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};vector&lt;int&gt; solution(vector&lt;int&gt; answers){ vector&lt;int&gt; answer; int i, j, k; vector&lt;int&gt; scoreN = {0, 0, 0}; for (i = 0; i &lt; answers.size(); i++) { if (fir[i % fir.size()] == answers[i]) { scoreN[0]++; } if (sec[i % sec.size()] == answers[i]) { scoreN[1]++; } if (thr[i % thr.size()] == answers[i]) { scoreN[2]++; } } int max_index = max_element(scoreN.begin(), scoreN.end()) - scoreN.begin(); for (i = 0; i &lt; 3; i++) { if (scoreN[i] == scoreN[max_index]) { answer.push_back(i + 1); } } sort(answer.begin(), answer.end()); return answer;}" }, { "title": "[프로그래머스] 기능개발 - 42586 (Python)", "url": "/posts/Programmers-42586/", "categories": "ProblemSolving, Programmers", "tags": "queue, python, level2", "date": "2022-07-05 16:09:03 +0900", "snippet": "문제 코딩테스트 연습 - 기능개발 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이문제의 유형은 큐를 쓰는 유형이었지만 정작 큐를 사용하지 않았다.큐를 이용하면 어떻게 풀 수 있을가에 대해 생각해봤고 그 풀이 방식은 아래와 같다. progresses의 인덱스 i에 대해서 (100-progresses[i]) / speeds[i] 를 진행했을 때 나머지가 존재하면 몫에서 1을 더해준 값이 완료까지 남은 날짜이다.나머지가 없다면 몫이 완료까지 남은 날짜이다.이들을 배열 remains에 progresses와 같은 인덱스로 저장한다. 큐 Q가 있을 때 remains에서 인덱스가 작은 순으로 Q에 넣어준다. Q에 넣으려는 값(A)보다 Q의 front값이 작다면 A를 넣기 전의 len(Q)를 answer에 append해주고 Q를 비우고 A를 넣어준다. remains의 모든 인덱스를 탐색했다면 마지막으로 len(Q)를 answer에 append해주면 끝이난다.코드def solution(progresses, speeds): remains = [] answer = [] for i in range(len(progresses)): if(100-progresses[i])%speeds[i]: remains.append((100-progresses[i])//speeds[i]+1) continue remains.append((100-progresses[i])//speeds[i]) index = 1 pre = remains[0] cnt = 1 while(True): if index == len(remains): break if pre &gt;= remains[index]: cnt += 1 else: answer.append(cnt) pre = remains[index] cnt = 1 index += 1 answer.append(cnt) return answer" }, { "title": "[프로그래머스] 더 맵게 - 42626 (Python)", "url": "/posts/Programmers-42626/", "categories": "ProblemSolving, Programmers", "tags": "heap, python, level2", "date": "2022-07-04 18:10:39 +0900", "snippet": "문제 코딩테스트 연습 - 더 맵게 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이가장 스코빌 지수가 낮은 음식을 루프를 돌 때마다 찾아야한다. 이는 우선순위 큐(heap)으로 해결할 수 있으며 파이썬에서 heap을 사용해보고자 언어를 파이썬으로 진행하였다.파이썬에서는 heapq와 PriorityQueue가 존재하는데 그 중 heapq를 사용하여 진행하였다.음식의 갯수와 값에 따라 여러 조건이 나오는데 내용은 아래와 같다. 남은 음식의 갯수가 1개. 이 상황은 음식을 더 이상 섞을 수 없으므로 해당 음식의 스코빌지수에 따라 answer값을 결정해주면 된다. 음식 갯수가 2개 이상 + 스코빌 지수가 가장 낮은 음식의 값 &lt; K. 음식을 섞어줘야하므로 스코빌 지수가 두 번째로 낮은 음식의 값을 찾아서 섞어준다. 이 때 heap에서는 음식 2개를 빼고 섞은 음식 1개를 새로 추가해주면 된다. 한 번 음식을 섞으므로 answer = answer + 1을 해준다. 음식 갯수가 2개 이상 + 스코빌 지수가 가장 낮은 음식의 값 ≥ K. 음식을 더 이상 섞을 필요가 없으므로 그대로 answer를 return 해준다. 구현에서는 while문을 탈출해줬다. Codeimport heapqdef solution(scoville, K): answer = 0 heapq.heapify(scoville) while(True): if(len(scoville) &gt;= 2 and scoville[0] &lt; K): first = heapq.heappop(scoville) second = heapq.heappop(scoville) heapq.heappush(scoville, first+2*second) answer += 1 continue break if scoville[0] &lt; K: answer = -1 return answer" }, { "title": "[프로그래머스] 짝지어 제거하기 - 12973 (C++)", "url": "/posts/Programmers-12973/", "categories": "ProblemSolving, Programmers", "tags": "stack, cpp, level2", "date": "2022-07-03 14:50:00 +0900", "snippet": "문제 코딩테스트 연습 - 짝지어 제거하기 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이문자열에서 같은 문자가 붙어있으면 지워나가며 모든 문자를 지울 수 있는지 확인하는 문제이다.문제에서는 해결을 위한 자료구조로 stack을 생각해냈는지가 중요했다.abba라는 문자열이 있다고 할 때 bb를 지우고 나면 왼쪽 a(이하 a1)와 오른쪽 a(이하 a2)가 만나서 지워진다. a2 입장에서 볼 때 a1과 만난다는 것을 확인할 때 필요한 정보는 bb 이전에 오는 문자에 관한 정보이다. 즉 과거의 지워지지 않은 문자들을 index순서대로 쌓아두는 방식이 필요한데 이 때 필요한 것이 stack이다. 문자열 s를 index 순으로 진행한다. index가 끝나면 4)로 간다.2-1. stack이 비어있으면 stack에 s[index]를 넣고 1)로 간다.2-2. stack에 문자가 있다면 stack의 top과 s[index]를 비교한다.3-1. top==s[index]면 top을 stack에서 지우고 1)로 간다.3-2. top≠s[index]면 stack에 s[index]를 넣고 1)로 간다. stack이 비었으면 모든 문자를 지운 것이므로 answer = 1, stack이 남아있으면 answer = 0이다. Code#include &lt;bits/stdc++.h&gt;using namespace std;int solution(string s){ int answer = -1; int i; stack&lt;char&gt; stk; stk.push(s[0]); for (i = 1; i &lt; s.size(); i++) { if (stk.empty()) { stk.push(s[i]); continue; } if (stk.top() == s[i]) { stk.pop(); continue; } stk.push(s[i]); } answer = stk.empty() ? 1 : 0; return answer;}" }, { "title": "[프로그래머스] 보석 쇼핑 - 67258 (Python)", "url": "/posts/Programmers-67258/", "categories": "ProblemSolving, Programmers", "tags": "two pointer, python, level3", "date": "2022-07-01 19:28:20 +0900", "snippet": "문제 코딩테스트 연습 - 보석 쇼핑 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이무작위 보석들이 담긴 배열이 주어질 때 모든 보석이 최소 하나씩은 들어간 가장 짧은 구간을 찾는 two pointer 문제이다. gem_dict에 보석의 종류를 저장해주고 보석을 탐색할 때 가장 앞부분은 head, 가장 뒷부분은 tail로 표시하고 진행하였다. 풀이 과정은 다음과 같다. tail을 1씩 늘리면서 새로운 보석을 구간에 넣는다. head에 해당하는 보석을 없애도 구간에 해당 보석이 하나 이상 존재하는지 확인한다.이는 dict형식인 cur_range에 보석의 종류마다 갯수를 기록해두는 것으로 확인할 수 있다. 만약 head를 빼도 된다면 cur_range에서 head에 해당하는 보석을 하나 빼준다. cur_range에 있는 보석의 종류와 gem_dict에 있는 보석의 종류가 같다면( == len이 같다면) 해당 구간에 모든 보석이 최소 하나씩은 존재한다는 의미이므로 정답의 후보가 될 수 있다. 결과를 저장해둘 변수 result_len과 비교하여 현재 head~tail 의 길이가 result_len보다 짧다면 result_len에 기록해둔다.만약 result_len과 길이가 같다면 문제의 조건 “시작 진열대 번호가 가장 작은 구간”에 따라 result에 기록할 필요가 없다. tail이 보석 진열대의 끝에 도달하면 끝이 난다. Codedef solution(gems): gem_dict = {} for i in gems: if i in gem_dict: gem_dict[i] += 1 else : gem_dict[i] = 1 result_len = 987654321 result_head = 0 result_tail = 0 cur_range = {} head = 0 tail = 0 while tail &lt; len(gems): if gems[tail] in cur_range: cur_range[gems[tail]] += 1 else: cur_range[gems[tail]] = 1 while gems[head] in cur_range and cur_range[gems[head]] &gt; 1: cur_range[gems[head]] -= 1 head += 1 if len(gem_dict) == len(cur_range) and result_len &gt; tail-head+1: result_len = tail-head+1 result_head = head result_tail = tail tail+=1 answer = [] answer.append(result_head+1) answer.append(result_tail+1) return answer" }, { "title": "[프로그래머스] 가장 먼 노드 - 49189 (C++)", "url": "/posts/Programmers-49189/", "categories": "ProblemSolving, Programmers", "tags": "bfs, cpp, level3", "date": "2022-06-30 16:27:30 +0900", "snippet": "문제 코딩테스트 연습 - 가장 먼 노드 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이노드 1에서 가장 멀리 있는 노드의 갯수를 구하는 문제이다. 문제에서 입력 edge가 간선으로 연결된 노드 쌍을 나타내므로 2차원 vector를 이용하여 list node 형식으로 바꾸어준 후 bfs를 통해 진행하였다. visited 배열은 값이 0이면 방문하지 않은 노드이며 1이상이면 노드 1과의 거리를 나타낸다. max_value에서 나올 수 있는 거리 값의 최대를 저장해두며 모든 bfs가 끝난 후 visited의 값과 max_value가 같은 노드의 갯수를 세어서 answer에 저장해주면 끝이 난다. Code#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;int solution(int n, vector&lt;vector&lt;int&gt;&gt; edge){ // init int i, j, k; int answer = 0; vector&lt;vector&lt;int&gt;&gt; node_list(n + 1); // set node with list for (i = 0; i &lt; edge.size(); i++) { node_list[edge[i][0]].push_back(edge[i][1]); node_list[edge[i][1]].push_back(edge[i][0]); } // bfs queue&lt;pii&gt; q; vector&lt;int&gt; visited(n + 1); int max_value = 0; q.push(pii(1, 1)); while (!q.empty()) { pii front = q.front(); q.pop(); int index = front.first; int value = front.second; if (!visited[index]) { visited[index] = value; for (i = 0; i &lt; node_list[index].size(); i++) { q.push(pii(node_list[index][i], value + 1)); } if (max_value &lt; value) { max_value = value; } } } for (i = 1; i &lt;= n; i++) { if (visited[i] == max_value) { answer++; } } return answer;}" }, { "title": "[프로그래머스] 오픈채팅방 - 42888 (Python)", "url": "/posts/Programmers-42888/", "categories": "ProblemSolving, Programmers", "tags": "greedy, python, level2", "date": "2022-06-29 19:14:20 +0900", "snippet": "문제 코딩테스트 연습 - 오픈채팅방 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이사람마다 정해진 고유 id가 있고 이름만 계속 변하기 때문에 dict를 통해서 id와 name으로 key, value를 정해주었다. 모든 record를 돌면서 Change와 Enter처럼 name이 바뀌는 경우를 찾아서 해당 id의 name을 수정해주기만 하면 된다.그 후 다시 record를 돌면서 최종적으로 정해진 이름을 실제 record에 대입해주면 된다. Codedef solution(record): answer = [] id_name_dict = {} for words in record: word_list = words.split(\" \") command = word_list[0] uid = word_list[1] if command == \"Leave\": continue name = word_list[2] id_name_dict[uid] = name for words in record: word_list = words.split(\" \") command = word_list[0] name = id_name_dict[word_list[1]] if command == \"Leave\": answer.append(name + \"님이 나갔습니다.\") continue if command == \"Enter\": answer.append(name + \"님이 들어왔습니다.\") return answerprint(solution( [\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\", \"Leave uid1234\", \"Enter uid1234 Prodo\", \"Change uid4567 Ryan\"]))" }, { "title": "[프로그래머스] 124 나라의 숫자 - 12899 (C++)", "url": "/posts/Programmers-12899/", "categories": "ProblemSolving, Programmers", "tags": "greedy, cpp, level2", "date": "2022-06-28 23:47:40 +0900", "snippet": "문제 코딩테스트 연습 - 124 나라의 숫자 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이10진법의 수를 1, 2, 4만을 사용하여 표현하는 문제이다. 처음에는 진법 변환을 바탕으로 풀이를 진행하였으나 0을 사용하지 않는다는 점 때문에 해당 방식으로는 해결할 수 없었다. 결국 모든 자릿수는 0이 될 수 없으므로 1이상의 숫자로 채워져야한다는 의미이다. 그래서 생각해낸 방식은 다음과 같다. n이하의 숫자들 중 모든 3진법 자릿수에 1을 채우는 수를 구한다. 즉 n보다 작거나 같으며 3^x의 합들로 구성된 숫자들 중 최댓값을 구한다. 해당 수를 자릿수 단위로 count 배열에 기록하고 n에서 뺀다. 가장 큰 x부터 시작하여 1씩 감소하는 x가 있다고 하자. n을 3^x로 나누었을 때 그 몫이 변수q에 저장한다. q가 3이면(4이상은 논리적으로 나올 수 없다.) q를 2로 바꿔준다. q*3^x를 n에서 빼주고 count배열에 3^x위치에 해당하는 값을 q만큼 더해준다. 모든 과정이 진행되면 count배열에는 1~3 값을 가지는 배열이 나온다. 3값을 4로 치환해주고 count배열을 역순으로(뒤에서부터) 읽어주면 정답(answer)이 된다.말이 두서가 없는 것 같다. 나중에 다시 생각을 정리해서 정리된 풀이를 설명하고 싶다.개선할 점0이 없어 모든 자릿수가 채워져야함을 조금더 일찍 파악했으면 좋았을 것 같다. 시행착오가 너무 오래 걸렸다. Code#include &lt;bits/stdc++.h&gt;using namespace std;// additional variables and functionsint all_arr[20] = { 0,};int nextV[4] = {0, 0, 1, 2};char realV[4] = {'0', '1', '2', '4'};string solution(int n){ string answer = \"\"; int itemp = 1; int cnt = 0; while (true) { if (itemp &gt; n) { break; } n -= itemp; all_arr[cnt] = 1; itemp *= 3; cnt++; } while (itemp) { int quo = n / itemp; int rem = n % itemp; if (quo == 3) { quo = 2; } n -= itemp * quo; all_arr[cnt] += quo; itemp /= 3; cnt--; } int i = 0; char ctemp; stack&lt;char&gt; s; while (i &lt;= 19) { ctemp = realV[all_arr[i++]]; if (ctemp == '0') { break; } s.push(ctemp); } while (!s.empty()) { answer.push_back(s.top()); s.pop(); } return answer;}// main functionint main(){ // fastio; int i, j, k; // init for (i = 1; i &lt; 20; i++) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; solution(i) &lt;&lt; endl; } return 0;}" }, { "title": "[프로그래머스] 문자열 압축 - 60057 (Python)", "url": "/posts/Programmers-60057/", "categories": "ProblemSolving, Programmers", "tags": "greedy, python, level2", "date": "2022-06-27 22:58:20 +0900", "snippet": "문제 코딩테스트 연습 - 문자열 압축 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이Run-Length Encoding(RLE)를 구현해보는 문제이다. 처음에는 loop를 돌면서 길이를 loop_result에 저장해서 진행하는 형식으로 구현하였다. 하지만 마지막 부분을 index 처리하는 과정에서 문제가 생겨서 해당 방식 대신 loop_result에 직접 결과가 되는 string을 저장하는 방식으로 구현하였다.개선할 점직접 구현하는 방식 또한 문제를 해결하는 좋은 방안이 될 수 있다. Codedef solution(s): s_len = len(s) answer = s_len # i는 끊을 단어 수 for block_len in range(1, s_len // 2 + 1): # 압축된 길이를 기록 loop_result = \"\" prev = s[0:block_len] cnt = 1 for cur_index in range(block_len, s_len, block_len): # 이전 쌍과 비교해서 같으면 압축, 내용 저장 if prev == s[cur_index:cur_index + block_len]: cnt += 1 continue # 이전 쌍과 다르고 앞에 저장된 내용이 있다면 결과에 반영 if cnt &gt; 1: loop_result += str(cnt) loop_result += prev prev = s[cur_index:cur_index + block_len] cnt = 1 # 마지막 쌍 비교해서 반영 if cnt &gt; 1: loop_result += str(cnt) loop_result += prev # 결과 비교 if answer &gt; len(loop_result): answer = len(loop_result) return answer" }, { "title": "[프로그래머스] 입국심사 - 43238 (C++)", "url": "/posts/Programmers-43238/", "categories": "ProblemSolving, Programmers", "tags": "binary search, cpp, level3", "date": "2022-06-26 21:25:50 +0900", "snippet": "문제 코딩테스트 연습 - 입국심사 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이심사 시간이 정해져있으므로 특정 시간 T에 모든 사람이 통과할 수 있는지를 확인하고 이분 탐색을 통해 T를 찾아주면 된다. i번째 심사원이 T 시간 동안 처리할 수 있는 사람의 수를 구한다 1)에서 구한 모든 사람의 수를 더하면 T 시간 동안 통과한 사람의 수 cnt를 구할 수 있다. n과 cnt를 비교하여 이분탐색을 진행한다.개선할 점처음에 right값 즉, 최대값의 범위를 long long의 최댓값으로 정해주었다. 하지만 조금 더 계산의 범위를 줄이려고 한다면 심사원의 최대값과 모든 인원수를 곱해주면 된다. 곱해진 값은 해당 문제에서 발생할 수 있는 최악의 경우이며 long long의 최대값 보다 작다. Code#include &lt;bits/stdc++.h&gt;using namespace std;// additional variables and functionslong long solution(int n, vector&lt;int&gt; times){ int t = times.size(), i, j, k; long long answer; long long left, right, mid, cnt; left = 0, right = times.back() * ((long long)n); sort(times.begin(), times.end()); while (left &lt;= right) { cnt = 0; mid = (left + right) / 2; for (i = 0; i &lt; t; i++) { cnt += mid / times[i]; } if (n &lt;= cnt) { answer = mid; right = mid - 1; } else { left = mid + 1; } } return answer;}// main functionint main(){ // fastio; int i, j, k; // init vector&lt;int&gt; v; v.push_back(7); v.push_back(10); cout &lt;&lt; solution(6, v); return 0;}" }, { "title": "[프로그래머스] N으로 표현 - 42895 (C++)", "url": "/posts/Programmers-42895/", "categories": "ProblemSolving, Programmers", "tags": "dp, cpp, level3", "date": "2022-06-24 23:05:50 +0900", "snippet": "문제 코딩테스트 연습 - N으로 표현 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이(N을 K번 사용한 값)을 찾기 위해서는 (N을 i번 사용한 값)과 (K-i번 사용한 값)을 사칙연산 통해 구할 수 있다. 처음에는 N을 K번 붙이는 경우를 고려하지 않아서 해결하기 어려웠다. 하지만 NN은 N에서 10을 곱하고 N을 더한 값이며 N을 2번 사용한 경우에 해당된다. 이를 for문을 통해 적용해주면 된다.개선할 점다른 풀이들을 살펴보던 중 unordered_set을 이용한 글을 보았다. 해당 set에 원하는 숫자(number)가 있는지를 찾는 문제이므로 set이 정렬되는지 여부는 중요하지 않다. 따라서 성능을 조금이라도 더 올리고자 한다면 unordered_set을 이용할 수 있다. Code#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;set&lt;int&gt;&gt; v(9);int solution(int N, int number){ // init int answer = 0; int i, K, l, cur, fir, sec; // N을 붙여 나감 int NN = N; for (i = 1; i &lt; 9; i++) { v[i].insert(NN); NN = NN * 10 + N; } // N이 K번 사용되기 위해서는 i번 + K-i번의 사칙연산을 이용하면 된다. for (K = 2; K &lt; 9; K++) { for (i = 1; i &lt; K; i++) { for (auto j = v[i].begin(); j != v[i].end(); j++) { for (auto k = v[K - i].begin(); k != v[K - i].end(); k++) { v[K].insert(*j + *k); if (*j - *k &gt; 0) { v[K].insert(*j - *k); } v[K].insert(*j * *k); if (*k) { v[K].insert(*j / *k); } } } } } for (i = 1; i &lt; 9; i++) { if (v[i].find(number) != v[i].end()) { return i; } } return -1;}// main functionint main(){ // fastio; int i, j, k; // init cout &lt;&lt; solution(2, 11); return 0;}" }, { "title": "[프로그래머스] [1차] 추석 트래픽 - 17676 (Python)", "url": "/posts/Programmers-17676/", "categories": "ProblemSolving, Programmers", "tags": "greedy, python, level3", "date": "2022-06-23 18:03:50 +0900", "snippet": "문제 코딩테스트 연습 - [1차] 추석 트래픽 프로그래머스 코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요. school.programmers.co.kr 풀이처음에 문제를 접했을 때에는 배열을 이용하여 진행하고자 하였다.하지만 배열의 크기도 커지고 시간이 매우 오래 걸려서 포기하였다.문제 해결을 위해 사용한 방법은 다음과 같다. 모든 입력의 (시작시간, 종료시간)을 구한다. 입력은 문제 조건에 따라 종료시간 기준으로 정렬되어있기에 처음부터 차례대로 진행한다2-1. i번째 입력에 대해서 i보다 큰 모든 입력을 j라고 하고 cnt = 1로 정한다.2-2. j번째 입력의 시작시간이 i번째 입력의 종료시간보다 앞서면(작으면) cnt += 1해준다. cnt의 값과 answer를 비교해서 큰 값을 저장해준다. Codedef get_pair(line): arr = line.split() end_time = arr[1].split(':') end_hour = int(end_time[0]) * 60 * 60 * 1000 end_minute = int(end_time[1]) * 60 * 1000 end_second = int(float(end_time[2]) * 1000) end_time = end_hour + end_minute + end_second duration = int(float(arr[2].split('s')[0]) * 1000) - 1 return end_time, durationchange_list = []def solution(lines): answer = 0 for line in lines: change_list.append(get_pair(line)) for i in range(len(change_list)): pair = change_list[i] start_time = pair[0] end_time = start_time + 999 print(end_time) cnt = 1 for j in range(i + 1, len(change_list)): after_pair = change_list[j] range_time = after_pair[0] - after_pair[1] print(range_time) if range_time &lt;= end_time: cnt += 1 print(1) if answer &lt; cnt: answer = cnt print(\"=============================\") return answerinputs = [\"2016-09-15 20:59:57.421 0.351s\" , \"2016-09-15 20:59:58.233 1.181s\" , \"2016-09-15 20:59:58.299 0.8s\", \"2016-09-15 20:59:58.688 1.041s\", \"2016-09-15 20:59:59.591 1.412s\", \"2016-09-15 21:00:00.464 1.466s\", \"2016-09-15 21:00:00.741 1.581s\", \"2016-09-15 21:00:00.748 2.31s\", \"2016-09-15 21:00:00.966 0.381s\", \"2016-09-15 21:00:02.066 2.62s\"]print(solution(inputs))" }, { "title": "Test", "url": "/posts/test/", "categories": "", "tags": "", "date": "2022-06-23 00:00:00 +0900", "snippet": "First post in blogthis is test file for check.testingtry to more. end of the post." } ]
